{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///./bundle.js","webpack:///./lib/extensions/inputmask.extensions.js","webpack:///./lib/inputmask.js","webpack:///./lib/dependencyLibs/inputmask.dependencyLib.js","webpack:///./lib/global/window.js","webpack:///./lib/maskset.js","webpack:///./lib/maskScope.js","webpack:///./lib/extensions/inputmask.date.extensions.js","webpack:///./lib/extensions/inputmask.numeric.extensions.js","webpack:///webpack/bootstrap"],"names":["webpackUniversalModuleDefinition","root","factory","exports","module","define","amd","a","i","window","require","Inputmask","extendDefinitions","A","validator","casing","&","#","extendAliases","cssunit","regex","url","autoUnmask","ip","mask","definitions","chrs","maskset","pos","strict","opts","buffer","RegExp","test","onUnMask","maskedValue","unmaskedValue","inputmode","email","greedy","onBeforePaste","pastedValue","toLowerCase","replace","*","-","mac","vin","V","clearIncomplete","$","document","generateMaskSet","analyseMask","maskScope","alias","options","internal","this","el","undefined","events","refreshValue","isPlainObject","extend","defaults","noMasksCache","userOptions","isRTL","numericInput","resolveAlias","aliasStr","aliasDefinition","prototype","aliases","importAttributeOptions","npt","dataAttribute","importOption","option","optionData","getAttribute","indexOf","importDataAttributes","attrOptions","dataoptions","p","JSON","parse","dir","rightAlign","style","textAlign","removeAttribute","Object","keys","length","placeholder","optionalmarker","quantifiermarker","groupmarker","alternatormarker","escapeChar","oncomplete","noop","onincomplete","oncleared","repeat","removeMaskOnSubmit","clearMaskOnLostFocus","insertMode","onKeyDown","onBeforeMask","isFunction","call","onBeforeWrite","showMaskOnFocus","showMaskOnHover","onKeyValidation","skipOptionalPartCharacter","undoOnEscape","radixPoint","_radixDance","groupSeparator","keepStatic","positionCaretOnTab","tabThrough","supportsInputType","ignorables","isComplete","preValidation","postValidation","staticDefinitionSymbol","jitMasking","nullable","inputEventOnly","noValuePatching","positionCaretOnClick","colorMask","disablePredictiveText","shiftPositions","9","definitionSymbol","masksCache","elems","that","getElementById","querySelectorAll","nodeName","each","ndx","scopedOpts","inputmask","remove","data","action","noremask","_typeof","unmaskedvalue","value","getemptymask","hasMaskedValue","getmetadata","isValid","format","metadata","setValue","trigger","positionColorMask","input","template","left","offsetLeft","extendDefaults","definition","unmask","escapeRegex","str","specials","join","keyCode","BACKSPACE","BACKSPACE_SAFARI","DELETE","DOWN","END","ENTER","ESCAPE","HOME","INSERT","LEFT","PAGE_DOWN","PAGE_UP","RIGHT","SPACE","TAB","UP","X","CONTROL","dependencyLib","list","elem","len","isWindow","obj","isArraylike","ltype","nodeType","isValidElement","Element","DependencyLib","querySelector","eventRegistry","on","handler","addEvent","ev","namespace","addEventListener","attachEvent","push","_events","split","endx","nsEvent","off","removeEvent","removeEventListener","detachEvent","nmsp","splice","resolveNamespace","evts","hndx","hndL","evNdx","offEvents","offEventsL","type","evnt","params","bubbles","cancelable","detail","arguments","createEvent","CustomEvent","e","initCustomEvent","dispatchEvent","createEventObject","eventType","fireEvent","Event","apply","isArray","Array","inArray","arr","valHooks","constructor","hasOwnProperty","name","src","copy","copyIsArray","clone","target","deep","callback","owner","key","__data","event","evt","eval","__webpack_require__","__WEBPACK_AMD_DEFINE_RESULT__","nocache","ms","generateMask","regexMask","masksetDefinition","maskdefKey","repeatStart","reverse","maskToken","validPositions","_buffer","tests","excludes","maskLength","jitOffset","charAt","altMask","msk","pop","tokenizer","regexTokenizer","escaped","currentToken","MaskToken","match","m","openenings","maskTokens","openingToken","currentOpeningToken","alternator","lastMatch","closeRegexGroup","isGroup","isOptional","isQuantifier","isAlternator","matches","openGroup","alternatorGroup","quantifier","min","max","insertTestDefinition","mtoken","element","position","prevMatch","fn","static","optionality","newBlockMarker","def","nativeDef","lmnt","maskdef","verifyGroupMarker","token","nextToken","defaultCase","mndx","reverseTokens","reverseStatic","st","intMatch","parseInt","qt","groupify","groupToken","closeGroup","groupQuantifier","exec","altRegexGroup","mqj","mq","mq0","isNaN","mq1","jit","tmpMatch","subToken","ua","navigator","userAgent","ie","mobile","isInputEventSupported","iemobile","iphone","eventName","createElement","evName","isSupported","setAttribute","actionObj","undoValue","$el","skipKeyPressEvent","skipInputEvent","ignorable","maxLength","mouseEnter","originalPlaceholder","getMaskTemplate","baseOnInput","minimalPos","includeMode","noJit","clearOptionalTail","maskTemplate","ndxIntlzr","testPos","getMaskSet","generatedInput","determineTestTemplate","getTests","locator","slice","getPlaceholder","getTestTemplate","isFinite","resetMaskSet","soft","getLastValidPosition","closestTo","before","after","valids","posNdx","psNdx","getDecisionTaker","tst","decisionTaker","alternation","toString","getLocator","align","mloc","altTest","getTest","targetLocator","tstLocator","closest","bestMatch","distance","Math","abs","optionalQuantifier","tstPs","positionCanMatchDefinition","valid","tndx","ndxInitializer","insertStop","latestMatch","cacheDependency","resolveTestFromToken","loopNdx","quantifierRecurse","handleMatch","isFirstMatch","tokenGroup","firstMatch","resolveNdxInitializer","alternateNdx","targetAlternation","indexPos","ndxPos","bestMatchAltIndex","isSubsetOf","source","expand","pattern","expanded","start","end","l","charCodeAt","String","fromCharCode","staticCanMatchDefinition","sloc","tloc","canMatch","setMergeLocators","targetMatch","altMatch","locNdx","cd","optionalToken","mtchsNdx","mtch","alternateToken","malternateMatches","maltMatches","currentMatches","loopNdxCnt","altIndex","shift","currentPos","ndxInitializerClone","altIndexArr","amndx","altIndexArrClone","unMatchedAlternation","concat","ndx1","dropMatch","ndx2","altMatch2","qndx","mergeLocators","previousPos","mtndx","getBufferTemplate","getBuffer","noCache","refreshFromBuffer","valResult","caret","toUpperCase","posBefore","args","checkAlternationMatch","altArr1","altArr2","na","altArrC","isMatch","naArr","naNdx","alndx","alternate","c","fromIsValid","rAltPos","validPsClone","lastAlt","isValidRslt","altPos","prevAltPos","validPos","decisionPos","lAltPos","insertPosition","insert","targetLvp","posOffset","validInputsClone","staticInputsBeforePos","validInputs","fromAlternate","validateOnly","isSelection","posObj","begin","maskPos","processCommandObject","commandObj","sort","b","revalidateMask","refresh","rewritePosition","_isValid","rslt","validatedPos","result","positionsClone","currentPosValid","seekNext","isMask","nPos","snPos","trackbackPositions","postResult","endResult","originalPos","newPos","fillOnly","ps","vp","np","cvpInput","validTest","IsEnclosedStatic","selection","posMatch","nextMatch","lvp","j","needsValidation","t","newBlock","seekPrevious","writeBuffer","caretPos","triggerEvents","_valueSet","renderColorMask","$input","nptVal","_valueGet","setTimeout","returnPL","staticAlternations","prevTest","HandleNativePlaceholder","nptValue","determineNewCaretPosition","selectedCaret","tabbed","doRadixFocus","clickPos","vps","radixPos","clickPosition","lvclickPosition","lastPosition","tt","EventRuler","eventHandler","imOpts","disabled","readOnly","ctrlKey","preventDefault","returnVal","stopPropagation","form","evArr","EventHandlers","keydownEvent","k","handleRemove","shiftKey","altKey","checkVal","keypressEvent","checkval","writeOut","which","charCode","metaKey","forwardPosition","writeOutBuffer","pasteEvent","originalEvent","inputValue","tempValue","valueBeforeCaret","substr","valueAfterCaret","clipboardData","getData","pasteValue","inputFallBackEvent","radixPointHandler","ieMobileHandler","inputChar","iv","offset","frontPart","backPart","frontBufferPart","backBufferPart","entries","isEntry","fpl","entry","keypress","keydown","beforeInputEvent","inputType","setValueEvent","applyInputValue","focusEvent","clickEvent","mouseleaveEvent","activeElement","newCaretPosition","cutEvent","clipData","setData","execCommand","blurEvent","mouseenterEvent","submitEvent","resetEvent","valueBuffer","nptvl","initiatingEvent","charCodes","initialNdx","isTemplateMatch","targetTemplate","charCodeNdx","staticMatches","prevCaretPos","sndx","nextValid","nextSndx","umValue","pndx","bufferValue","notranslate","translatePosition","range","selectionStart","selectionEnd","getSelection","getRangeAt","commonAncestorContainer","parentNode","startOffset","endOffset","createRange","duplicate","moveStart","text","scrollCalc","ownerDocument","defaultView","getComputedStyle","currentStyle","fontSize","scrollLeft","scrollWidth","setSelectionRange","firstChild","textNode","createTextNode","appendChild","setStart","setEnd","collapse","sel","removeAllRanges","addRange","createTextRange","moveEnd","select","determineLastRequiredPosition","returnDefinition","bl","positions","lvTest","lvTestAlt","complete","lrp","aml","pend","initializeColorMask","computedStyle","findCaretPos","clientx","textTransform","letterSpacing","height","width","visibility","whiteSpace","body","inputText","previousWidth","itl","innerHTML","offsetWidth","offset1","offset2","removeChild","className","insertBefore","clientX","clear","isStatic","setEntry","mtl","setCaret","getElementsByTagName","isElementTypeSupported","patchValueProperty","valueGet","valueSet","patchValhook","inputmaskpatch","valhookGet","get","valhookSet","set","getter","setter","installNativeValueSetFallback","__valueGet","getOwnPropertyDescriptor","getPrototypeOf","__proto__","object","valueProperty","defineProperty","configurable","tagName","textContent","__lookupGetter__","__lookupSetter__","__defineGetter__","__defineSetter__","__valueSet","overruleRTL","elementType","isContentEditable","autocorrect","initialValue","rl","lmib","cv","maskTarget","mtdt","formatCode","d","Date","setDate","getDate","dd","pad","ddd","dddd","setMonth","getMonth","mm","mmm","mmmm","yy","setFullYear","getFullYear","yyyy","h","setHours","getHours","hh","hhh","H","HH","HHH","M","setMinutes","getMinutes","MM","s","setSeconds","getSeconds","ss","setMilliseconds","getMilliseconds","L","T","TT","Z","o","S","formatAlias","isoDate","isoTime","isoDateTime","isoUtcDateTime","getTokenizer","tokens","isValidDate","dateParts","currentResult","rawday","day","rawyear","date","rawmonth","month","isDateInRange","rawYear","minYear","year","getTime","dateObjValue","raw","getFn","val","maskString","dateObj","targetProp","dateOperation","extendProperty","correctedValue","datetime","i18n","ordinalSuffix","inputFormat","displayFormat","outputFormat","dayNames","monthNames","calcPos","fuzzy","today","getYear","autoEscape","txt","escapedTxt","alignDigits","digits","digitsOptional","radixPosition","FindPlusValidator","tstNdx","ndxl","parseMinMaxOptions","parseFloat","NaN","Number","MIN_VALUE","MAX_VALUE","genMask","decimalDef","__financeInput","prefix","_mask","dq","suffix","console","log","hanndleRadixDance","decimalValidator","numeric","enforceDigitsOnBlur","allowMinus","negationSymbol","front","back","step","unmaskAsNumber","0","1","+","isNegative","unmasked","processValue","valueParts","integerPart","decimalPart","digitsFactor","pow","round","substring","currency","decimal","integer","percentage","indianns","installedModules","modules","enumerable","r","Symbol","toStringTag","mode","__esModule","ns","create","bind","n","getDefault","getModuleExports","property","moduleId"],"mappings":"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","file":"dist/inputmask.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(window, function() {\nreturn ","// import \"./css/inputmask.css\";\n\nrequire(\"./lib/extensions/inputmask.extensions\");\nrequire(\"./lib/extensions/inputmask.date.extensions\");\nrequire(\"./lib/extensions/inputmask.numeric.extensions\");\nmodule.exports = require(\"./lib/inputmask.js\");\n","/*\n Input Mask plugin extensions\n http://github.com/RobinHerbots/jquery.inputmask\n Copyright (c) Robin Herbots\n Licensed under the MIT license\n */\nvar Inputmask = require(\"../inputmask\");\n//extra definitions\nInputmask.extendDefinitions({\n\t\"A\": {\n\t\tvalidator: \"[A-Za-z\\u0410-\\u044F\\u0401\\u0451\\u00C0-\\u00FF\\u00B5]\",\n\t\tcasing: \"upper\" //auto uppercasing\n\t},\n\t\"&\": { //alfanumeric uppercasing\n\t\tvalidator: \"[0-9A-Za-z\\u0410-\\u044F\\u0401\\u0451\\u00C0-\\u00FF\\u00B5]\",\n\t\tcasing: \"upper\"\n\t},\n\t\"#\": { //hexadecimal\n\t\tvalidator: \"[0-9A-Fa-f]\",\n\t\tcasing: \"upper\"\n\t}\n});\nInputmask.extendAliases({\n\t\"cssunit\": {\n\t\tregex: \"[+-]?[0-9]+\\\\.?([0-9]+)?(px|em|rem|ex|%|in|cm|mm|pt|pc)\"\n\t},\n\t\"url\": { //needs update => https://en.wikipedia.org/wiki/URL\n\t\tregex: \"(https?|ftp)//.*\",\n\t\tautoUnmask: false\n\t},\n\t\"ip\": { //ip-address mask\n\t\tmask: \"i[i[i]].i[i[i]].i[i[i]].i[i[i]]\",\n\t\tdefinitions: {\n\t\t\t\"i\": {\n\t\t\t\tvalidator: function (chrs, maskset, pos, strict, opts) {\n\t\t\t\t\tif (pos - 1 > -1 && maskset.buffer[pos - 1] !== \".\") {\n\t\t\t\t\t\tchrs = maskset.buffer[pos - 1] + chrs;\n\t\t\t\t\t\tif (pos - 2 > -1 && maskset.buffer[pos - 2] !== \".\") {\n\t\t\t\t\t\t\tchrs = maskset.buffer[pos - 2] + chrs;\n\t\t\t\t\t\t} else chrs = \"0\" + chrs;\n\t\t\t\t\t} else chrs = \"00\" + chrs;\n\t\t\t\t\treturn new RegExp(\"25[0-5]|2[0-4][0-9]|[01][0-9][0-9]\").test(chrs);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tonUnMask: function (maskedValue, unmaskedValue, opts) {\n\t\t\treturn maskedValue;\n\t\t},\n\t\tinputmode: \"numeric\",\n\t},\n\t\"email\": {\n\t\t//https://en.wikipedia.org/wiki/Domain_name#Domain_name_space\n\t\t//https://en.wikipedia.org/wiki/Hostname#Restrictions_on_valid_host_names\n\t\t//should be extended with the toplevel domains at the end\n\t\tmask: \"*{1,64}[.*{1,64}][.*{1,64}][.*{1,63}]@-{1,63}.-{1,63}[.-{1,63}][.-{1,63}]\",\n\t\tgreedy: false,\n\t\tcasing: \"lower\",\n\t\tonBeforePaste: function (pastedValue, opts) {\n\t\t\tpastedValue = pastedValue.toLowerCase();\n\t\t\treturn pastedValue.replace(\"mailto:\", \"\");\n\t\t},\n\t\tdefinitions: {\n\t\t\t\"*\": {\n\t\t\t\tvalidator: \"[0-9\\uFF11-\\uFF19A-Za-z\\u0410-\\u044F\\u0401\\u0451\\u00C0-\\u00FF\\u00B5!#$%&'*+/=?^_`{|}~-]\"\n\t\t\t},\n\t\t\t\"-\": {\n\t\t\t\tvalidator: \"[0-9A-Za-z-]\"\n\t\t\t}\n\t\t},\n\t\tonUnMask: function (maskedValue, unmaskedValue, opts) {\n\t\t\treturn maskedValue;\n\t\t},\n\t\tinputmode: \"email\"\n\t},\n\t\"mac\": {\n\t\tmask: \"##:##:##:##:##:##\"\n\t},\n\t//https://en.wikipedia.org/wiki/Vehicle_identification_number\n\t// see issue #1199\n\t\"vin\": {\n\t\tmask: \"V{13}9{4}\",\n\t\tdefinitions: {\n\t\t\t\"V\": {\n\t\t\t\tvalidator: \"[A-HJ-NPR-Za-hj-npr-z\\\\d]\",\n\t\t\t\tcasing: \"upper\"\n\t\t\t}\n\t\t},\n\t\tclearIncomplete: true,\n\t\tautoUnmask: true\n\t}\n});\nmodule.exports = Inputmask;\n","/*\n * Input Mask Core\n * http://github.com/RobinHerbots/jquery.inputmask\n * Copyright (c) Robin Herbots\n * Licensed under the MIT license\n */\nvar $ = require(\"./dependencyLibs/inputmask.dependencyLib\"), window = require(\"./global/window\"),\n\tdocument = window.document,\n\tgenerateMaskSet = require(\"./maskset\").generateMaskSet,\n\tanalyseMask = require(\"./maskset\").analyseMask,\n\tmaskScope = require(\"./maskScope\");\n\n\nfunction Inputmask(alias, options, internal) {\n\t//allow instanciating without new\n\tif (!(this instanceof Inputmask)) {\n\t\treturn new Inputmask(alias, options, internal);\n\t}\n\n\tthis.el = undefined;\n\tthis.events = {};\n\tthis.maskset = undefined;\n\tthis.refreshValue = false; //indicate a refresh from the inputvalue is needed (form.reset)\n\n\tif (internal !== true) {\n\t\t//init options\n\t\tif ($.isPlainObject(alias)) {\n\t\t\toptions = alias;\n\t\t} else {\n\t\t\toptions = options || {};\n\t\t\tif (alias) options.alias = alias;\n\t\t}\n\t\tthis.opts = $.extend(true, {}, this.defaults, options);\n\t\tthis.noMasksCache = options && options.definitions !== undefined;\n\t\tthis.userOptions = options || {}; //user passed options\n\t\tthis.isRTL = this.opts.numericInput;\n\t\tresolveAlias(this.opts.alias, options, this.opts);\n\t}\n}\n\nInputmask.prototype = {\n\tdataAttribute: \"data-inputmask\", //data attribute prefix used for attribute binding\n\t//options default\n\tdefaults: {\n\t\tplaceholder: \"_\",\n\t\toptionalmarker: [\"[\", \"]\"],\n\t\tquantifiermarker: [\"{\", \"}\"],\n\t\tgroupmarker: [\"(\", \")\"],\n\t\talternatormarker: \"|\",\n\t\tescapeChar: \"\\\\\",\n\t\tmask: null, //needs tobe null instead of undefined as the extend method does not consider props with the undefined value\n\t\tregex: null, //regular expression as a mask\n\t\toncomplete: $.noop, //executes when the mask is complete\n\t\tonincomplete: $.noop, //executes when the mask is incomplete and focus is lost\n\t\toncleared: $.noop, //executes when the mask is cleared\n\t\trepeat: 0, //repetitions of the mask: * ~ forever, otherwise specify an integer\n\t\tgreedy: false, //true: allocated buffer for the mask and repetitions - false: allocate only if needed\n\t\tautoUnmask: false, //automatically unmask when retrieving the value with $.fn.val or value if the browser supports __lookupGetter__ or getOwnPropertyDescriptor\n\t\tremoveMaskOnSubmit: false, //remove the mask before submitting the form.\n\t\tclearMaskOnLostFocus: true,\n\t\tinsertMode: true, //insert the input or overwrite the input\n\t\tclearIncomplete: false, //clear the incomplete input on blur\n\t\talias: null,\n\t\tonKeyDown: $.noop, //callback to implement autocomplete on certain keys for example. args => event, buffer, caretPos, opts\n\t\tonBeforeMask: null, //executes before masking the initial value to allow preprocessing of the initial value.\targs => initialValue, opts => return processedValue\n\t\tonBeforePaste: function (pastedValue, opts) {\n\t\t\treturn $.isFunction(opts.onBeforeMask) ? opts.onBeforeMask.call(this, pastedValue, opts) : pastedValue;\n\t\t}, //executes before masking the pasted value to allow preprocessing of the pasted value.\targs => pastedValue, opts => return processedValue\n\t\tonBeforeWrite: null, //executes before writing to the masked element. args => event, opts\n\t\tonUnMask: null, //executes after unmasking to allow postprocessing of the unmaskedvalue.\targs => maskedValue, unmaskedValue, opts\n\t\tshowMaskOnFocus: true, //show the mask-placeholder when the input has focus\n\t\tshowMaskOnHover: true, //show the mask-placeholder when hovering the empty input\n\t\tonKeyValidation: $.noop, //executes on every key-press with the result of isValid. Params: key, result, opts\n\t\tskipOptionalPartCharacter: \" \", //a character which can be used to skip an optional part of a mask\n\t\tnumericInput: false, //numericInput input direction style (input shifts to the left while holding the caret position)\n\t\trightAlign: false, //align to the right\n\t\tundoOnEscape: true, //pressing escape reverts the value to the value before focus\n\t\t//numeric basic properties\n\t\tradixPoint: \"\", //\".\", // | \",\"\n\t\t_radixDance: false, //dance around the radixPoint\n\t\tgroupSeparator: \"\", //\",\", // | \".\"\n\t\t//numeric basic properties\n\t\tkeepStatic: null, //try to keep the mask static while typing. Decisions to alter the mask will be posponed if possible - null see auto selection for multi masks\n\t\tpositionCaretOnTab: true, //when enabled the caret position is set after the latest valid position on TAB\n\t\ttabThrough: false, //allows for tabbing through the different parts of the masked field\n\t\tsupportsInputType: [\"text\", \"tel\", \"url\", \"password\", \"search\"], //list with the supported input types\n\t\t//specify keyCodes which should not be considered in the keypress event, otherwise the preventDefault will stop their default behavior especially in FF\n\t\tignorables: [8, 9, 13, 19, 27, 33, 34, 35, 36, 37, 38, 39, 40, 45, 46, 93, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 0, 229],\n\t\tisComplete: null, //override for isComplete - args => buffer, opts - return true || false\n\t\tpreValidation: null, //hook to preValidate the input.  Usefull for validating regardless the definition.\targs => buffer, pos, char, isSelection, opts => return true/false/command object\n\t\tpostValidation: null, //hook to postValidate the result from isValid.\tUsefull for validating the entry as a whole.\targs => buffer, pos, currentResult, opts => return true/false/json\n\t\tstaticDefinitionSymbol: undefined, //specify a definitionSymbol for static content, used to make matches for alternators\n\t\tjitMasking: false, //just in time masking ~ only mask while typing, can n (number), true or false\n\t\tnullable: true, //return nothing instead of the buffertemplate when the user hasn't entered anything.\n\t\tinputEventOnly: false, //dev option - testing inputfallback behavior\n\t\tnoValuePatching: false, //disable value property patching\n\t\tpositionCaretOnClick: \"lvp\", //none, lvp (based on the last valid position (default), radixFocus (position caret to radixpoint on initial click), select (select the whole input), ignore (ignore the click and continue the mask)\n\t\tcasing: null, //mask-level casing. Options: null, \"upper\", \"lower\" or \"title\" or callback args => elem, test, pos, validPositions return charValue\n\t\tinputmode: \"verbatim\", //specify the inputmode  - already in place for when browsers will support it\n\t\tcolorMask: false, //enable css styleable mask\n\t\tdisablePredictiveText: false, //disable Predictive Text on mobile devices\n\t\timportDataAttributes: true, //import data-inputmask attributes\n\t\tshiftPositions: true //shift position of the mask entries on entry and deletion.\n\t},\n\tdefinitions: {\n\t\t\"9\": { //\\uFF11-\\uFF19 #1606\n\t\t\tvalidator: \"[0-9\\uFF11-\\uFF19]\",\n\t\t\tdefinitionSymbol: \"*\"\n\t\t},\n\t\t\"a\": { //\\u0410-\\u044F\\u0401\\u0451\\u00C0-\\u00FF\\u00B5 #76\n\t\t\tvalidator: \"[A-Za-z\\u0410-\\u044F\\u0401\\u0451\\u00C0-\\u00FF\\u00B5]\",\n\t\t\tdefinitionSymbol: \"*\"\n\t\t},\n\t\t\"*\": {\n\t\t\tvalidator: \"[0-9\\uFF11-\\uFF19A-Za-z\\u0410-\\u044F\\u0401\\u0451\\u00C0-\\u00FF\\u00B5]\"\n\t\t}\n\t},\n\taliases: {}, //aliases definitions\n\tmasksCache: {},\n\tmask: function (elems) {\n\t\tvar that = this;\n\t\tif (typeof elems === \"string\") {\n\t\t\telems = document.getElementById(elems) || document.querySelectorAll(elems);\n\t\t}\n\t\telems = elems.nodeName ? [elems] : elems;\n\t\t$.each(elems, function (ndx, el) {\n\t\t\tvar scopedOpts = $.extend(true, {}, that.opts);\n\t\t\tif (importAttributeOptions(el, scopedOpts, $.extend(true, {}, that.userOptions), that.dataAttribute)) {\n\t\t\t\tvar maskset = generateMaskSet(scopedOpts, that.noMasksCache);\n\t\t\t\tif (maskset !== undefined) {\n\t\t\t\t\tif (el.inputmask !== undefined) {\n\t\t\t\t\t\tel.inputmask.opts.autoUnmask = true; //force autounmasking when remasking\n\t\t\t\t\t\tel.inputmask.remove();\n\t\t\t\t\t}\n\t\t\t\t\t//store inputmask instance on the input with element reference\n\t\t\t\t\tel.inputmask = new Inputmask(undefined, undefined, true);\n\t\t\t\t\tel.inputmask.opts = scopedOpts;\n\t\t\t\t\tel.inputmask.noMasksCache = that.noMasksCache;\n\t\t\t\t\tel.inputmask.userOptions = $.extend(true, {}, that.userOptions);\n\t\t\t\t\tel.inputmask.isRTL = scopedOpts.isRTL || scopedOpts.numericInput;\n\t\t\t\t\tel.inputmask.el = el;\n\t\t\t\t\tel.inputmask.maskset = maskset;\n\n\t\t\t\t\t$.data(el, \"_inputmask_opts\", scopedOpts);\n\n\t\t\t\t\tmaskScope.call(el.inputmask, {\n\t\t\t\t\t\t\"action\": \"mask\"\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn elems && elems[0] ? (elems[0].inputmask || this) : this;\n\t},\n\toption: function (options, noremask) { //set extra options || retrieve value of a current option\n\t\tif (typeof options === \"string\") {\n\t\t\treturn this.opts[options];\n\t\t} else if (typeof options === \"object\") {\n\t\t\t$.extend(this.userOptions, options); //user passed options\n\t\t\t//remask\n\t\t\tif (this.el && noremask !== true) {\n\t\t\t\tthis.mask(this.el);\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t},\n\tunmaskedvalue: function (value) {\n\t\tthis.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache);\n\t\treturn maskScope.call(this, {\n\t\t\t\"action\": \"unmaskedvalue\",\n\t\t\t\"value\": value\n\t\t});\n\t},\n\tremove: function () {\n\t\treturn maskScope.call(this, {\n\t\t\t\"action\": \"remove\"\n\t\t});\n\t},\n\tgetemptymask: function () { //return the default (empty) mask value, usefull for setting the default value in validation\n\t\tthis.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache);\n\t\treturn maskScope.call(this, {\n\t\t\t\"action\": \"getemptymask\"\n\t\t});\n\t},\n\thasMaskedValue: function () { //check wheter the returned value is masked or not; currently only works reliable when using jquery.val fn to retrieve the value\n\t\treturn !this.opts.autoUnmask;\n\t},\n\tisComplete: function () {\n\t\tthis.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache);\n\t\treturn maskScope.call(this, {\n\t\t\t\"action\": \"isComplete\"\n\t\t});\n\t},\n\tgetmetadata: function () { //return mask metadata if exists\n\t\tthis.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache);\n\t\treturn maskScope.call(this, {\n\t\t\t\"action\": \"getmetadata\"\n\t\t});\n\t},\n\tisValid: function (value) {\n\t\tthis.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache);\n\t\treturn maskScope.call(this, {\n\t\t\t\"action\": \"isValid\",\n\t\t\t\"value\": value\n\t\t});\n\t},\n\tformat: function (value, metadata) {\n\t\tthis.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache);\n\t\treturn maskScope.call(this, {\n\t\t\t\"action\": \"format\",\n\t\t\t\"value\": value,\n\t\t\t\"metadata\": metadata //true/false getmetadata\n\t\t});\n\t},\n\tsetValue: function (value) {\n\t\tif (this.el) {\n\t\t\t$(this.el).trigger(\"setvalue\", [value]);\n\t\t}\n\t},\n\tanalyseMask: analyseMask,\n\tpositionColorMask: function (input, template) {\n\t\tinput.style.left = template.offsetLeft + \"px\";\n\t}\n};\n\nfunction resolveAlias(aliasStr, options, opts) {\n\tvar aliasDefinition = Inputmask.prototype.aliases[aliasStr];\n\tif (aliasDefinition) {\n\t\tif (aliasDefinition.alias) resolveAlias(aliasDefinition.alias, undefined, opts); //alias is another alias\n\t\t$.extend(true, opts, aliasDefinition); //merge alias definition in the options\n\t\t$.extend(true, opts, options); //reapply extra given options\n\t\treturn true;\n\t} else //alias not found - try as mask\n\tif (opts.mask === null) {\n\t\topts.mask = aliasStr;\n\t}\n\n\treturn false;\n}\n\nfunction importAttributeOptions(npt, opts, userOptions, dataAttribute) {\n\tfunction importOption(option, optionData) {\n\t\toptionData = optionData !== undefined ? optionData : npt.getAttribute(dataAttribute + \"-\" + option);\n\t\tif (optionData !== null) {\n\t\t\tif (typeof optionData === \"string\") {\n\t\t\t\tif (option.indexOf(\"on\") === 0) {\n\t\t\t\t\toptionData = window[optionData];\n\t\t\t\t}//get function definition\n\t\t\t\telse if (optionData === \"false\") {\n\t\t\t\t\toptionData = false;\n\t\t\t\t} else if (optionData === \"true\") optionData = true;\n\t\t\t}\n\t\t\tuserOptions[option] = optionData;\n\t\t}\n\t}\n\n\tif (opts.importDataAttributes === true) {\n\t\tvar attrOptions = npt.getAttribute(dataAttribute), option, dataoptions, optionData, p;\n\n\t\tif (attrOptions && attrOptions !== \"\") {\n\t\t\tattrOptions = attrOptions.replace(/'/g, \"\\\"\");\n\t\t\tdataoptions = JSON.parse(\"{\" + attrOptions + \"}\");\n\t\t}\n\n\t\t//resolve aliases\n\t\tif (dataoptions) { //pickup alias from dataAttribute\n\t\t\toptionData = undefined;\n\t\t\tfor (p in dataoptions) {\n\t\t\t\tif (p.toLowerCase() === \"alias\") {\n\t\t\t\t\toptionData = dataoptions[p];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\timportOption(\"alias\", optionData); //pickup alias from dataAttribute-alias\n\t\tif (userOptions.alias) {\n\t\t\tresolveAlias(userOptions.alias, userOptions, opts);\n\t\t}\n\n\t\tfor (option in opts) {\n\t\t\tif (dataoptions) {\n\t\t\t\toptionData = undefined;\n\t\t\t\tfor (p in dataoptions) {\n\t\t\t\t\tif (p.toLowerCase() === option.toLowerCase()) {\n\t\t\t\t\t\toptionData = dataoptions[p];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\timportOption(option, optionData);\n\t\t}\n\t}\n\t$.extend(true, opts, userOptions);\n\n\t//handle dir=rtl\n\tif (npt.dir === \"rtl\" || opts.rightAlign) {\n\t\tnpt.style.textAlign = \"right\";\n\t}\n\n\tif (npt.dir === \"rtl\" || opts.numericInput) {\n\t\tnpt.dir = \"ltr\";\n\t\tnpt.removeAttribute(\"dir\");\n\t\topts.isRTL = true;\n\t}\n\n\treturn Object.keys(userOptions).length;\n}\n\n//apply defaults, definitions, aliases\nInputmask.extendDefaults = function (options) {\n\t$.extend(true, Inputmask.prototype.defaults, options);\n};\nInputmask.extendDefinitions = function (definition) {\n\t$.extend(true, Inputmask.prototype.definitions, definition);\n};\nInputmask.extendAliases = function (alias) {\n\t$.extend(true, Inputmask.prototype.aliases, alias);\n};\n//static fn on inputmask\nInputmask.format = function (value, options, metadata) {\n\treturn Inputmask(options).format(value, metadata);\n};\nInputmask.unmask = function (value, options) {\n\treturn Inputmask(options).unmaskedvalue(value);\n};\nInputmask.isValid = function (value, options) {\n\treturn Inputmask(options).isValid(value);\n};\nInputmask.remove = function (elems) {\n\tif (typeof elems === \"string\") {\n\t\telems = document.getElementById(elems) || document.querySelectorAll(elems);\n\t}\n\telems = elems.nodeName ? [elems] : elems;\n\t$.each(elems, function (ndx, el) {\n\t\tif (el.inputmask) el.inputmask.remove();\n\t});\n};\nInputmask.setValue = function (elems, value) {\n\tif (typeof elems === \"string\") {\n\t\telems = document.getElementById(elems) || document.querySelectorAll(elems);\n\t}\n\telems = elems.nodeName ? [elems] : elems;\n\t$.each(elems, function (ndx, el) {\n\t\tif (el.inputmask) el.inputmask.setValue(value); else $(el).trigger(\"setvalue\", [value]);\n\t});\n};\nInputmask.escapeRegex = function (str) {\n\tvar specials = [\"/\", \".\", \"*\", \"+\", \"?\", \"|\", \"(\", \")\", \"[\", \"]\", \"{\", \"}\", \"\\\\\", \"$\", \"^\"];\n\treturn str.replace(new RegExp(\"(\\\\\" + specials.join(\"|\\\\\") + \")\", \"gim\"), \"\\\\$1\");\n};\nInputmask.keyCode = {\n\tBACKSPACE: 8,\n\tBACKSPACE_SAFARI: 127,\n\tDELETE: 46,\n\tDOWN: 40,\n\tEND: 35,\n\tENTER: 13,\n\tESCAPE: 27,\n\tHOME: 36,\n\tINSERT: 45,\n\tLEFT: 37,\n\tPAGE_DOWN: 34,\n\tPAGE_UP: 33,\n\tRIGHT: 39,\n\tSPACE: 32,\n\tTAB: 9,\n\tUP: 38,\n\tX: 88,\n\tCONTROL: 17\n};\nInputmask.dependencyLib = $;\n\n//make inputmask available\nwindow.Inputmask = Inputmask;\nmodule.exports = Inputmask;\n","/*\n Input Mask plugin dependencyLib\n http://github.com/RobinHerbots/jquery.inputmask\n Copyright (c) Robin Herbots\n Licensed under the MIT license\n */\n\nvar window = require(\"../global/window\"), document = window.document;\n//helper functions\n\n// Use a stripped-down indexOf as it's faster than native\n// http://jsperf.com/thor-indexof-vs-for/5\nfunction indexOf(list, elem) {\n\tvar i = 0,\n\t\tlen = list.length;\n\tfor (; i < len; i++) {\n\t\tif (list[i] === elem) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\nfunction isWindow(obj) {\n\treturn obj != null && obj === obj[\"window\"];\n}\n\nfunction isArraylike(obj) {\n\t// Support: iOS 8.2 (not reproducible in simulator)\n\t// `in` check used to prevent JIT error (gh-2145)\n\t// hasOwn isn't used here due to false negatives\n\t// regarding Nodelist length in IE\n\tvar length = \"length\" in obj && obj.length,\n\t\tltype = typeof obj;\n\n\tif (ltype === \"function\" || isWindow(obj)) {\n\t\treturn false;\n\t}\n\n\tif (obj.nodeType === 1 && length) {\n\t\treturn true;\n\t}\n\n\treturn ltype === \"array\" || length === 0 ||\n\t\ttypeof length === \"number\" && length > 0 && (length - 1) in obj;\n}\n\nfunction isValidElement(elem) {\n\treturn elem instanceof Element;\n}\n\nfunction DependencyLib(elem) {\n\tif (elem instanceof DependencyLib) {\n\t\treturn elem;\n\t}\n\tif (!(this instanceof DependencyLib)) {\n\t\treturn new DependencyLib(elem);\n\t}\n\tif (elem !== undefined && elem !== null && elem !== window) {\n\t\tthis[0] = elem.nodeName ? elem : (elem[0] !== undefined && elem[0].nodeName ? elem[0] : document.querySelector(elem));\n\t\tif (this[0] !== undefined && this[0] !== null) {\n\t\t\tthis[0].eventRegistry = this[0].eventRegistry || {};\n\t\t}\n\t}\n}\n\nDependencyLib.prototype = {\n\ton: function (events, handler) {\n\t\tfunction addEvent(ev, namespace) {\n\t\t\t//register domevent\n\t\t\tif (elem.addEventListener) { // all browsers except IE before version 9\n\t\t\t\telem.addEventListener(ev, handler, false);\n\t\t\t} else if (elem.attachEvent) { // IE before version 9\n\t\t\t\telem.attachEvent(\"on\" + ev, handler);\n\t\t\t}\n\t\t\teventRegistry[ev] = eventRegistry[ev] || {};\n\t\t\teventRegistry[ev][namespace] = eventRegistry[ev][namespace] || [];\n\t\t\teventRegistry[ev][namespace].push(handler);\n\t\t}\n\n\t\tif (isValidElement(this[0])) {\n\t\t\tvar eventRegistry = this[0].eventRegistry,\n\t\t\t\telem = this[0];\n\n\n\t\t\tvar _events = events.split(\" \");\n\t\t\tfor (var endx = 0; endx < _events.length; endx++) {\n\t\t\t\tvar nsEvent = _events[endx].split(\".\"),\n\t\t\t\t\tev = nsEvent[0],\n\t\t\t\t\tnamespace = nsEvent[1] || \"global\";\n\t\t\t\taddEvent(ev, namespace);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t},\n\toff: function (events, handler) {\n\t\tvar eventRegistry, elem;\n\n\t\tfunction removeEvent(ev, namespace, handler) {\n\t\t\tif (ev in eventRegistry === true) {\n\t\t\t\t//unbind to dom events\n\t\t\t\tif (elem.removeEventListener) { // all browsers except IE before version 9\n\t\t\t\t\telem.removeEventListener(ev, handler, false);\n\t\t\t\t} else if (elem.detachEvent) { // IE before version 9\n\t\t\t\t\telem.detachEvent(\"on\" + ev, handler);\n\t\t\t\t}\n\t\t\t\tif (namespace === \"global\") {\n\t\t\t\t\tfor (var nmsp in eventRegistry[ev]) {\n\t\t\t\t\t\teventRegistry[ev][nmsp].splice(eventRegistry[ev][nmsp].indexOf(handler), 1);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\teventRegistry[ev][namespace].splice(eventRegistry[ev][namespace].indexOf(handler), 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction resolveNamespace(ev, namespace) {\n\t\t\tvar evts = [],\n\t\t\t\thndx, hndL;\n\t\t\tif (ev.length > 0) {\n\t\t\t\tif (handler === undefined) {\n\t\t\t\t\tfor (hndx = 0, hndL = eventRegistry[ev][namespace].length; hndx < hndL; hndx++) {\n\t\t\t\t\t\tevts.push({\n\t\t\t\t\t\t\tev: ev,\n\t\t\t\t\t\t\tnamespace: namespace && namespace.length > 0 ? namespace : \"global\",\n\t\t\t\t\t\t\thandler: eventRegistry[ev][namespace][hndx]\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tevts.push({\n\t\t\t\t\t\tev: ev,\n\t\t\t\t\t\tnamespace: namespace && namespace.length > 0 ? namespace : \"global\",\n\t\t\t\t\t\thandler: handler\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else if (namespace.length > 0) {\n\t\t\t\tfor (var evNdx in eventRegistry) {\n\t\t\t\t\tfor (var nmsp in eventRegistry[evNdx]) {\n\t\t\t\t\t\tif (nmsp === namespace) {\n\t\t\t\t\t\t\tif (handler === undefined) {\n\t\t\t\t\t\t\t\tfor (hndx = 0, hndL = eventRegistry[evNdx][nmsp].length; hndx < hndL; hndx++) {\n\t\t\t\t\t\t\t\t\tevts.push({\n\t\t\t\t\t\t\t\t\t\tev: evNdx,\n\t\t\t\t\t\t\t\t\t\tnamespace: nmsp,\n\t\t\t\t\t\t\t\t\t\thandler: eventRegistry[evNdx][nmsp][hndx]\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tevts.push({\n\t\t\t\t\t\t\t\t\tev: evNdx,\n\t\t\t\t\t\t\t\t\tnamespace: nmsp,\n\t\t\t\t\t\t\t\t\thandler: handler\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn evts;\n\t\t}\n\n\t\tif (isValidElement(this[0])) {\n\t\t\teventRegistry = this[0].eventRegistry;\n\t\t\telem = this[0];\n\n\n\t\t\tvar _events = events.split(\" \");\n\t\t\tfor (var endx = 0; endx < _events.length; endx++) {\n\t\t\t\tvar nsEvent = _events[endx].split(\".\"),\n\t\t\t\t\toffEvents = resolveNamespace(nsEvent[0], nsEvent[1]);\n\t\t\t\tfor (var i = 0, offEventsL = offEvents.length; i < offEventsL; i++) {\n\t\t\t\t\tremoveEvent(offEvents[i].ev, offEvents[i].namespace, offEvents[i].handler);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t},\n\ttrigger: function (events /* , args... */) {\n\t\tif (isValidElement(this[0])) {\n\t\t\tvar eventRegistry = this[0].eventRegistry,\n\t\t\t\telem = this[0];\n\t\t\tvar _events = typeof events === \"string\" ? events.split(\" \") : [events.type];\n\t\t\tfor (var endx = 0; endx < _events.length; endx++) {\n\t\t\t\tvar nsEvent = _events[endx].split(\".\"),\n\t\t\t\t\tev = nsEvent[0],\n\t\t\t\t\tnamespace = nsEvent[1] || \"global\";\n\t\t\t\tif (document !== undefined && namespace === \"global\") {\n\t\t\t\t\t//trigger domevent\n\t\t\t\t\tvar evnt, i, params = {\n\t\t\t\t\t\tbubbles: true,\n\t\t\t\t\t\tcancelable: true,\n\t\t\t\t\t\tdetail: arguments[1]\n\t\t\t\t\t};\n\t\t\t\t\t// The custom event that will be created\n\t\t\t\t\tif (document.createEvent) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tevnt = new CustomEvent(ev, params);\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\tevnt = document.createEvent(\"CustomEvent\");\n\t\t\t\t\t\t\tevnt.initCustomEvent(ev, params.bubbles, params.cancelable, params.detail);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (events.type) DependencyLib.extend(evnt, events);\n\t\t\t\t\t\telem.dispatchEvent(evnt);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tevnt = document.createEventObject();\n\t\t\t\t\t\tevnt.eventType = ev;\n\t\t\t\t\t\tevnt.detail = arguments[1];\n\t\t\t\t\t\tif (events.type) DependencyLib.extend(evnt, events);\n\t\t\t\t\t\telem.fireEvent(\"on\" + evnt.eventType, evnt);\n\t\t\t\t\t}\n\t\t\t\t} else if (eventRegistry[ev] !== undefined) {\n\t\t\t\t\targuments[0] = arguments[0].type ? arguments[0] : DependencyLib.Event(arguments[0]);\n\t\t\t\t\tif (namespace === \"global\") {\n\t\t\t\t\t\tfor (var nmsp in eventRegistry[ev]) {\n\t\t\t\t\t\t\tfor (i = 0; i < eventRegistry[ev][nmsp].length; i++) {\n\t\t\t\t\t\t\t\teventRegistry[ev][nmsp][i].apply(elem, arguments);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (i = 0; i < eventRegistry[ev][namespace].length; i++) {\n\t\t\t\t\t\t\teventRegistry[ev][namespace][i].apply(elem, arguments);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n};\n\n//static\nDependencyLib.isFunction = function (obj) {\n\treturn typeof obj === \"function\";\n};\nDependencyLib.noop = function () {\n};\nDependencyLib.isArray = Array.isArray;\nDependencyLib.inArray = function (elem, arr, i) {\n\treturn arr == null ? -1 : indexOf(arr, elem, i);\n};\nDependencyLib.valHooks = undefined;\n\n\nDependencyLib.isPlainObject = function (obj) {\n\t// Not plain objects:\n\t// - Any object or value whose internal [[Class]] property is not \"[object Object]\"\n\t// - DOM nodes\n\t// - window\n\tif (typeof obj !== \"object\" || obj.nodeType || isWindow(obj)) {\n\t\treturn false;\n\t}\n\n\tif (obj.constructor && !Object.hasOwnProperty.call(obj.constructor.prototype, \"isPrototypeOf\")) {\n\t\treturn false;\n\t}\n\n\t// If the function hasn't returned already, we're confident that\n\t// |obj| is a plain object, created by {} or constructed with new Object\n\treturn true;\n};\n\nDependencyLib.extend = function () {\n\tvar options, name, src, copy, copyIsArray, clone,\n\t\ttarget = arguments[0] || {},\n\t\ti = 1,\n\t\tlength = arguments.length,\n\t\tdeep = false;\n\n\t// Handle a deep copy situation\n\tif (typeof target === \"boolean\") {\n\t\tdeep = target;\n\n\t\t// Skip the boolean and the target\n\t\ttarget = arguments[i] || {};\n\t\ti++;\n\t}\n\n\t// Handle case when target is a string or something (possible in deep copy)\n\tif (typeof target !== \"object\" && !DependencyLib.isFunction(target)) {\n\t\ttarget = {};\n\t}\n\n\t// Extend jQuery itself if only one argument is passed\n\tif (i === length) {\n\t\ttarget = this;\n\t\ti--;\n\t}\n\n\tfor (; i < length; i++) {\n\t\t// Only deal with non-null/undefined values\n\t\tif ((options = arguments[i]) != null) {\n\t\t\t// Extend the base object\n\t\t\tfor (name in options) {\n\t\t\t\tsrc = target[name];\n\t\t\t\tcopy = options[name];\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif (target === copy) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\tif (deep && copy && (DependencyLib.isPlainObject(copy) || (copyIsArray = DependencyLib.isArray(copy)))) {\n\t\t\t\t\tif (copyIsArray) {\n\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\tclone = src && DependencyLib.isArray(src) ? src : [];\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tclone = src && DependencyLib.isPlainObject(src) ? src : {};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\ttarget[name] = DependencyLib.extend(deep, clone, copy);\n\n\t\t\t\t\t// Don't bring in undefined values\n\t\t\t\t} else if (copy !== undefined) {\n\t\t\t\t\ttarget[name] = copy;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n\nDependencyLib.each = function (obj, callback) {\n\tvar value, i = 0;\n\n\tif (isArraylike(obj)) {\n\t\tfor (var length = obj.length; i < length; i++) {\n\t\t\tvalue = callback.call(obj[i], i, obj[i]);\n\t\t\tif (value === false) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (i in obj) {\n\t\t\tvalue = callback.call(obj[i], i, obj[i]);\n\t\t\tif (value === false) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn obj;\n};\n\nDependencyLib.data = function (owner, key, value) {\n\tif (value === undefined) {\n\t\treturn owner.__data ? owner.__data[key] : null;\n\t} else {\n\t\towner.__data = owner.__data || {};\n\t\towner.__data[key] = value;\n\t}\n};\n\nif (typeof window.CustomEvent === \"function\") {\n\tDependencyLib.Event = window.CustomEvent;\n} else {\n\tDependencyLib.Event = function (event, params) {\n\t\tparams = params || {bubbles: false, cancelable: false, detail: undefined};\n\t\tvar evt = document.createEvent(\"CustomEvent\");\n\t\tevt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\n\t\treturn evt;\n\t};\n\tDependencyLib.Event.prototype = window.Event.prototype;\n}\n\nmodule.exports = DependencyLib;\n","if (typeof define === \"function\" && define.amd)\n\tdefine(function () {\n\t\treturn typeof window !== \"undefined\" ? window : new (eval(\"require('jsdom').JSDOM\"))(\"\").window;\n\t});\nelse if (typeof exports === \"object\")\n\tmodule.exports = typeof window !== \"undefined\" ? window : new (eval(\"require('jsdom').JSDOM\"))(\"\").window;\n\n","var $ = require(\"./dependencyLibs/inputmask.dependencyLib\");\n\nfunction generateMaskSet(opts, nocache) {\n\tvar ms;\n\n\tfunction generateMask(mask, metadata, opts) {\n\t\tvar regexMask = false;\n\t\tif (mask === null || mask === \"\") {\n\t\t\tregexMask = opts.regex !== null;\n\t\t\tif (regexMask) {\n\t\t\t\tmask = opts.regex;\n\t\t\t\tmask = mask.replace(/^(\\^)(.*)(\\$)$/, \"$2\");\n\t\t\t} else {\n\t\t\t\tregexMask = true;\n\t\t\t\tmask = \".*\";\n\t\t\t}\n\t\t}\n\t\tif (mask.length === 1 && opts.greedy === false && opts.repeat !== 0) {\n\t\t\topts.placeholder = \"\";\n\t\t} //hide placeholder with single non-greedy mask\n\t\tif (opts.repeat > 0 || opts.repeat === \"*\" || opts.repeat === \"+\") {\n\t\t\tvar repeatStart = opts.repeat === \"*\" ? 0 : (opts.repeat === \"+\" ? 1 : opts.repeat);\n\t\t\tmask = opts.groupmarker[0] + mask + opts.groupmarker[1] + opts.quantifiermarker[0] + repeatStart + \",\" + opts.repeat + opts.quantifiermarker[1];\n\t\t}\n\n\t\t// console.log(mask);\n\t\tvar masksetDefinition, maskdefKey;\n\t\tmaskdefKey = regexMask ? \"regex_\" + opts.regex : opts.numericInput ? mask.split(\"\").reverse().join(\"\") : mask;\n\t\tif (opts.keepStatic !== false) { //keepstatic modifies the output from the testdefinitions ~ so differentiate in the maskcache\n\t\t\tmaskdefKey = \"ks_\" + maskdefKey;\n\t\t}\n\n\t\tif (Inputmask.prototype.masksCache[maskdefKey] === undefined || nocache === true) {\n\t\t\tmasksetDefinition = {\n\t\t\t\t\"mask\": mask,\n\t\t\t\t\"maskToken\": Inputmask.prototype.analyseMask(mask, regexMask, opts),\n\t\t\t\t\"validPositions\": {},\n\t\t\t\t\"_buffer\": undefined,\n\t\t\t\t\"buffer\": undefined,\n\t\t\t\t\"tests\": {},\n\t\t\t\t\"excludes\": {}, //excluded alternations\n\t\t\t\t\"metadata\": metadata,\n\t\t\t\t\"maskLength\": undefined,\n\t\t\t\t\"jitOffset\": {}\n\t\t\t};\n\t\t\tif (nocache !== true) {\n\t\t\t\tInputmask.prototype.masksCache[maskdefKey] = masksetDefinition;\n\t\t\t\tmasksetDefinition = $.extend(true, {}, Inputmask.prototype.masksCache[maskdefKey]);\n\t\t\t}\n\t\t} else {\n\t\t\tmasksetDefinition = $.extend(true, {}, Inputmask.prototype.masksCache[maskdefKey]);\n\t\t}\n\n\t\treturn masksetDefinition;\n\t}\n\n\tif ($.isFunction(opts.mask)) { //allow mask to be a preprocessing fn - should return a valid mask\n\t\topts.mask = opts.mask(opts);\n\t}\n\tif ($.isArray(opts.mask)) {\n\t\tif (opts.mask.length > 1) {\n\t\t\tif (opts.keepStatic === null) { //enable by default when passing multiple masks when the option is not explicitly specified\n\t\t\t\topts.keepStatic = \"auto\";\n\t\t\t\tfor (var i = 0; i < opts.mask.length; i++) {\n\t\t\t\t\tif (opts.mask[i].charAt(0) !== opts.mask[0].charAt(0)) {\n\t\t\t\t\t\topts.keepStatic = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar altMask = opts.groupmarker[0];\n\t\t\t$.each(opts.isRTL ? opts.mask.reverse() : opts.mask, function (ndx, msk) {\n\t\t\t\tif (altMask.length > 1) {\n\t\t\t\t\taltMask += opts.groupmarker[1] + opts.alternatormarker + opts.groupmarker[0];\n\t\t\t\t}\n\t\t\t\tif (msk.mask !== undefined && !$.isFunction(msk.mask)) {\n\t\t\t\t\taltMask += msk.mask;\n\t\t\t\t} else {\n\t\t\t\t\taltMask += msk;\n\t\t\t\t}\n\t\t\t});\n\t\t\taltMask += opts.groupmarker[1];\n\t\t\t// console.log(altMask);\n\t\t\treturn generateMask(altMask, opts.mask, opts);\n\t\t} else {\n\t\t\topts.mask = opts.mask.pop();\n\t\t}\n\t}\n\n\tif (opts.mask && opts.mask.mask !== undefined && !$.isFunction(opts.mask.mask)) {\n\t\tms = generateMask(opts.mask.mask, opts.mask, opts);\n\t} else {\n\t\tms = generateMask(opts.mask, opts.mask, opts);\n\t}\n\n\treturn ms;\n}\n\nfunction analyseMask(mask, regexMask, opts) {\n\tvar tokenizer = /(?:[?*+]|\\{[0-9+*]+(?:,[0-9+*]*)?(?:\\|[0-9+*]*)?\\})|[^.?*+^${[]()|\\\\]+|./g,\n\t\t//Thx to https://github.com/slevithan/regex-colorizer for the regexTokenizer regex\n\t\tregexTokenizer = /\\[\\^?]?(?:[^\\\\\\]]+|\\\\[\\S\\s]?)*]?|\\\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9][0-9]*|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}|c[A-Za-z]|[\\S\\s]?)|\\((?:\\?[:=!]?)?|(?:[?*+]|\\{[0-9]+(?:,[0-9]*)?\\})\\??|[^.?*+^${[()|\\\\]+|./g,\n\t\tescaped = false,\n\t\tcurrentToken = new MaskToken(),\n\t\tmatch,\n\t\tm,\n\t\topenenings = [],\n\t\tmaskTokens = [],\n\t\topeningToken,\n\t\tcurrentOpeningToken,\n\t\talternator,\n\t\tlastMatch,\n\t\tcloseRegexGroup = false;\n\n\tfunction MaskToken(isGroup, isOptional, isQuantifier, isAlternator) {\n\t\tthis.matches = [];\n\t\tthis.openGroup = isGroup || false;\n\t\tthis.alternatorGroup = false;\n\t\tthis.isGroup = isGroup || false;\n\t\tthis.isOptional = isOptional || false;\n\t\tthis.isQuantifier = isQuantifier || false;\n\t\tthis.isAlternator = isAlternator || false;\n\t\tthis.quantifier = {\n\t\t\tmin: 1,\n\t\t\tmax: 1\n\t\t};\n\t}\n\n\t//test definition => {fn: RegExp/function, static: true/false optionality: bool, newBlockMarker: bool, casing: null/upper/lower, def: definitionSymbol, placeholder: placeholder, mask: real maskDefinition}\n\tfunction insertTestDefinition(mtoken, element, position) {\n\t\tposition = position !== undefined ? position : mtoken.matches.length;\n\t\tvar prevMatch = mtoken.matches[position - 1];\n\t\tif (regexMask) {\n\t\t\tif (element.indexOf(\"[\") === 0 || (escaped && /\\\\d|\\\\s|\\\\w]/i.test(element)) || element === \".\") {\n\t\t\t\tmtoken.matches.splice(position++, 0, {\n\t\t\t\t\tfn: new RegExp(element, opts.casing ? \"i\" : \"\"),\n\t\t\t\t\tstatic: false,\n\t\t\t\t\toptionality: false,\n\t\t\t\t\tnewBlockMarker: prevMatch === undefined ? \"master\" : prevMatch.def !== element,\n\t\t\t\t\tcasing: null,\n\t\t\t\t\tdef: element,\n\t\t\t\t\tplaceholder: undefined,\n\t\t\t\t\tnativeDef: element\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tif (escaped) element = element[element.length - 1];\n\t\t\t\t$.each(element.split(\"\"), function (ndx, lmnt) {\n\t\t\t\t\tprevMatch = mtoken.matches[position - 1];\n\t\t\t\t\tmtoken.matches.splice(position++, 0, {\n\t\t\t\t\t\tfn: /[a-z]/i.test((opts.staticDefinitionSymbol || lmnt)) ? new RegExp(\"[\" + (opts.staticDefinitionSymbol || lmnt) + \"]\", opts.casing ? \"i\" : \"\") : null,\n\t\t\t\t\t\tstatic: true,\n\t\t\t\t\t\toptionality: false,\n\t\t\t\t\t\tnewBlockMarker: prevMatch === undefined ? \"master\" : (prevMatch.def !== lmnt && prevMatch.static !== true),\n\t\t\t\t\t\tcasing: null,\n\t\t\t\t\t\tdef: opts.staticDefinitionSymbol || lmnt,\n\t\t\t\t\t\tplaceholder: opts.staticDefinitionSymbol !== undefined ? lmnt : undefined,\n\t\t\t\t\t\tnativeDef: (escaped ? \"'\" : \"\") + lmnt\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\t\t\tescaped = false;\n\t\t} else {\n\t\t\tvar maskdef = (opts.definitions ? opts.definitions[element] : undefined) || Inputmask.prototype.definitions[element];\n\t\t\tif (maskdef && !escaped) {\n\t\t\t\tmtoken.matches.splice(position++, 0, {\n\t\t\t\t\tfn: maskdef.validator ? typeof maskdef.validator == \"string\" ? new RegExp(maskdef.validator, opts.casing ? \"i\" : \"\") : new function () {\n\t\t\t\t\t\tthis.test = maskdef.validator;\n\t\t\t\t\t} : new RegExp(\".\"),\n\t\t\t\t\tstatic: false,\n\t\t\t\t\toptionality: false,\n\t\t\t\t\tnewBlockMarker: prevMatch === undefined ? \"master\" : prevMatch.def !== (maskdef.definitionSymbol || element),\n\t\t\t\t\tcasing: maskdef.casing,\n\t\t\t\t\tdef: maskdef.definitionSymbol || element,\n\t\t\t\t\tplaceholder: maskdef.placeholder,\n\t\t\t\t\tnativeDef: element\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tmtoken.matches.splice(position++, 0, {\n\t\t\t\t\tfn: /[a-z]/i.test((opts.staticDefinitionSymbol || element)) ? new RegExp(\"[\" + (opts.staticDefinitionSymbol || element) + \"]\", opts.casing ? \"i\" : \"\") : null,\n\t\t\t\t\tstatic: true,\n\t\t\t\t\toptionality: false,\n\t\t\t\t\tnewBlockMarker: prevMatch === undefined ? \"master\" : (prevMatch.def !== element && prevMatch.static !== true),\n\t\t\t\t\tcasing: null,\n\t\t\t\t\tdef: opts.staticDefinitionSymbol || element,\n\t\t\t\t\tplaceholder: opts.staticDefinitionSymbol !== undefined ? element : undefined,\n\t\t\t\t\tnativeDef: (escaped ? \"'\" : \"\") + element\n\t\t\t\t});\n\t\t\t\tescaped = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction verifyGroupMarker(maskToken) {\n\t\tif (maskToken && maskToken.matches) {\n\t\t\t$.each(maskToken.matches, function (ndx, token) {\n\t\t\t\tvar nextToken = maskToken.matches[ndx + 1];\n\t\t\t\tif ((nextToken === undefined || (nextToken.matches === undefined || nextToken.isQuantifier === false)) && token && token.isGroup) { //this is not a group but a normal mask => convert\n\t\t\t\t\ttoken.isGroup = false;\n\t\t\t\t\tif (!regexMask) {\n\t\t\t\t\t\tinsertTestDefinition(token, opts.groupmarker[0], 0);\n\t\t\t\t\t\tif (token.openGroup !== true) {\n\t\t\t\t\t\t\tinsertTestDefinition(token, opts.groupmarker[1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tverifyGroupMarker(token);\n\t\t\t});\n\t\t}\n\t}\n\n\tfunction defaultCase() {\n\t\tif (openenings.length > 0) {\n\t\t\tcurrentOpeningToken = openenings[openenings.length - 1];\n\t\t\tinsertTestDefinition(currentOpeningToken, m);\n\t\t\tif (currentOpeningToken.isAlternator) { //handle alternator a | b case\n\t\t\t\talternator = openenings.pop();\n\t\t\t\tfor (var mndx = 0; mndx < alternator.matches.length; mndx++) {\n\t\t\t\t\tif (alternator.matches[mndx].isGroup) alternator.matches[mndx].isGroup = false; //don't mark alternate groups as group\n\t\t\t\t}\n\t\t\t\tif (openenings.length > 0) {\n\t\t\t\t\tcurrentOpeningToken = openenings[openenings.length - 1];\n\t\t\t\t\tcurrentOpeningToken.matches.push(alternator);\n\t\t\t\t} else {\n\t\t\t\t\tcurrentToken.matches.push(alternator);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tinsertTestDefinition(currentToken, m);\n\t\t}\n\t}\n\n\tfunction reverseTokens(maskToken) {\n\t\tfunction reverseStatic(st) {\n\t\t\tif (st === opts.optionalmarker[0]) {\n\t\t\t\tst = opts.optionalmarker[1];\n\t\t\t} else if (st === opts.optionalmarker[1]) {\n\t\t\t\tst = opts.optionalmarker[0];\n\t\t\t} else if (st === opts.groupmarker[0]) {\n\t\t\t\tst = opts.groupmarker[1];\n\t\t\t} else if (st === opts.groupmarker[1]) st = opts.groupmarker[0];\n\n\t\t\treturn st;\n\t\t}\n\n\t\tmaskToken.matches = maskToken.matches.reverse();\n\t\tfor (var match in maskToken.matches) {\n\t\t\tif (maskToken.matches.hasOwnProperty(match)) {\n\t\t\t\tvar intMatch = parseInt(match);\n\t\t\t\tif (maskToken.matches[match].isQuantifier && maskToken.matches[intMatch + 1] && maskToken.matches[intMatch + 1].isGroup) { //reposition quantifier\n\t\t\t\t\tvar qt = maskToken.matches[match];\n\t\t\t\t\tmaskToken.matches.splice(match, 1);\n\t\t\t\t\tmaskToken.matches.splice(intMatch + 1, 0, qt);\n\t\t\t\t}\n\t\t\t\tif (maskToken.matches[match].matches !== undefined) {\n\t\t\t\t\tmaskToken.matches[match] = reverseTokens(maskToken.matches[match]);\n\t\t\t\t} else {\n\t\t\t\t\tmaskToken.matches[match] = reverseStatic(maskToken.matches[match]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn maskToken;\n\t}\n\n\tfunction groupify(matches) {\n\t\tvar groupToken = new MaskToken(true);\n\t\tgroupToken.openGroup = false;\n\t\tgroupToken.matches = matches;\n\t\treturn groupToken;\n\t}\n\n\tfunction closeGroup() {\n\t\t// Group closing\n\t\topeningToken = openenings.pop();\n\t\topeningToken.openGroup = false; //mark group as complete\n\t\tif (openingToken !== undefined) {\n\t\t\tif (openenings.length > 0) {\n\t\t\t\tcurrentOpeningToken = openenings[openenings.length - 1];\n\t\t\t\tcurrentOpeningToken.matches.push(openingToken);\n\t\t\t\tif (currentOpeningToken.isAlternator) { //handle alternator (a) | (b) case\n\t\t\t\t\talternator = openenings.pop();\n\t\t\t\t\tfor (var mndx = 0; mndx < alternator.matches.length; mndx++) {\n\t\t\t\t\t\talternator.matches[mndx].isGroup = false; //don't mark alternate groups as group\n\t\t\t\t\t\talternator.matches[mndx].alternatorGroup = false;\n\t\t\t\t\t}\n\t\t\t\t\tif (openenings.length > 0) {\n\t\t\t\t\t\tcurrentOpeningToken = openenings[openenings.length - 1];\n\t\t\t\t\t\tcurrentOpeningToken.matches.push(alternator);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcurrentToken.matches.push(alternator);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcurrentToken.matches.push(openingToken);\n\t\t\t}\n\t\t} else {\n\t\t\tdefaultCase();\n\t\t}\n\t}\n\n\tfunction groupQuantifier(matches) {\n\t\tvar lastMatch = matches.pop();\n\t\tif (lastMatch.isQuantifier) {\n\t\t\tlastMatch = groupify([matches.pop(), lastMatch]);\n\t\t}\n\t\treturn lastMatch;\n\t}\n\n\tif (regexMask) {\n\t\topts.optionalmarker[0] = undefined;\n\t\topts.optionalmarker[1] = undefined;\n\t}\n\twhile ((match = regexMask ? regexTokenizer.exec(mask) : tokenizer.exec(mask))) {\n\t\tm = match[0];\n\n\t\tif (regexMask) {\n\t\t\tswitch (m.charAt(0)) {\n\t\t\t\t//Quantifier\n\t\t\t\tcase \"?\":\n\t\t\t\t\tm = \"{0,1}\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"+\":\n\t\t\t\tcase \"*\":\n\t\t\t\t\tm = \"{\" + m + \"}\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"|\":\n\t\t\t\t\t//regex mask alternator  ex: [01][0-9]|2[0-3] => ([01][0-9]|2[0-3])\n\t\t\t\t\tif (openenings.length === 0) { //wrap the mask in a group to form a regex alternator  ([01][0-9]|2[0-3])\n\t\t\t\t\t\tvar altRegexGroup = groupify(currentToken.matches);\n\t\t\t\t\t\taltRegexGroup.openGroup = true;\n\t\t\t\t\t\topenenings.push(altRegexGroup);\n\t\t\t\t\t\tcurrentToken.matches = [];\n\t\t\t\t\t\tcloseRegexGroup = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (escaped) {\n\t\t\tdefaultCase();\n\t\t\tcontinue;\n\t\t}\n\t\tswitch (m.charAt(0)) {\n\t\t\tcase \"(?=\": //lookahead\n\t\t\t\tbreak;\n\t\t\tcase \"(?!\": //negative lookahead\n\t\t\t\tbreak;\n\t\t\tcase \"(?<=\": //lookbehind\n\t\t\t\tbreak;\n\t\t\tcase \"(?<!\": //negative lookbehind\n\t\t\t\tbreak;\n\t\t\tcase opts.escapeChar:\n\t\t\t\tescaped = true;\n\t\t\t\tif (regexMask) {\n\t\t\t\t\tdefaultCase();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// optional closing\n\t\t\tcase opts.optionalmarker[1]:\n\t\t\tcase opts.groupmarker[1]:\n\t\t\t\tcloseGroup();\n\t\t\t\tbreak;\n\t\t\tcase opts.optionalmarker[0]:\n\t\t\t\t// optional opening\n\t\t\t\topenenings.push(new MaskToken(false, true));\n\t\t\t\tbreak;\n\t\t\tcase opts.groupmarker[0]:\n\t\t\t\t// Group opening\n\t\t\t\topenenings.push(new MaskToken(true));\n\t\t\t\tbreak;\n\t\t\tcase opts.quantifiermarker[0]:\n\t\t\t\t//Quantifier\n\t\t\t\tvar quantifier = new MaskToken(false, false, true);\n\n\t\t\t\tm = m.replace(/[{}]/g, \"\");\n\t\t\t\tvar mqj = m.split(\"|\"),\n\t\t\t\t\tmq = mqj[0].split(\",\"),\n\t\t\t\t\tmq0 = isNaN(mq[0]) ? mq[0] : parseInt(mq[0]),\n\t\t\t\t\tmq1 = mq.length === 1 ? mq0 : (isNaN(mq[1]) ? mq[1] : parseInt(mq[1]));\n\t\t\t\tif (mq0 === \"*\" || mq0 === \"+\") {\n\t\t\t\t\tmq0 = mq1 === \"*\" ? 0 : 1;\n\t\t\t\t}\n\t\t\t\tquantifier.quantifier = {\n\t\t\t\t\tmin: mq0,\n\t\t\t\t\tmax: mq1,\n\t\t\t\t\tjit: mqj[1]\n\t\t\t\t};\n\t\t\t\tvar matches = openenings.length > 0 ? openenings[openenings.length - 1].matches : currentToken.matches;\n\t\t\t\tmatch = matches.pop();\n\t\t\t\tif (match.isAlternator) { //handle quantifier in an alternation [0-9]{2}|[0-9]{3}\n\t\t\t\t\tmatches.push(match); //push back alternator\n\t\t\t\t\tmatches = match.matches; //remap target matches\n\t\t\t\t\tvar groupToken = new MaskToken(true);\n\t\t\t\t\tvar tmpMatch = matches.pop();\n\t\t\t\t\tmatches.push(groupToken); //push the group\n\t\t\t\t\tmatches = groupToken.matches;\n\t\t\t\t\tmatch = tmpMatch;\n\t\t\t\t}\n\t\t\t\tif (!match.isGroup) {\n\t\t\t\t\t// if (regexMask && match.fn === null) { //why is this needed???\n\t\t\t\t\t//     if (match.def === \".\") match.fn = new RegExp(match.def, opts.casing ? \"i\" : \"\");\n\t\t\t\t\t// }\n\n\t\t\t\t\tmatch = groupify([match]);\n\t\t\t\t}\n\t\t\t\tmatches.push(match);\n\t\t\t\tmatches.push(quantifier);\n\n\t\t\t\tbreak;\n\t\t\tcase opts.alternatormarker:\n\n\n\t\t\t\tif (openenings.length > 0) {\n\t\t\t\t\tcurrentOpeningToken = openenings[openenings.length - 1];\n\t\t\t\t\tvar subToken = currentOpeningToken.matches[currentOpeningToken.matches.length - 1];\n\t\t\t\t\tif (currentOpeningToken.openGroup && //regexp alt syntax\n\t\t\t\t\t\t(subToken.matches === undefined || (subToken.isGroup === false && subToken.isAlternator === false))) { //alternations within group\n\t\t\t\t\t\tlastMatch = openenings.pop();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlastMatch = groupQuantifier(currentOpeningToken.matches);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlastMatch = groupQuantifier(currentToken.matches);\n\t\t\t\t}\n\t\t\t\tif (lastMatch.isAlternator) {\n\t\t\t\t\topenenings.push(lastMatch);\n\t\t\t\t} else {\n\t\t\t\t\tif (lastMatch.alternatorGroup) {\n\t\t\t\t\t\talternator = openenings.pop();\n\t\t\t\t\t\tlastMatch.alternatorGroup = false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\talternator = new MaskToken(false, false, false, true);\n\t\t\t\t\t}\n\t\t\t\t\talternator.matches.push(lastMatch);\n\t\t\t\t\topenenings.push(alternator);\n\t\t\t\t\tif (lastMatch.openGroup) { //regexp alt syntax\n\t\t\t\t\t\tlastMatch.openGroup = false;\n\t\t\t\t\t\tvar alternatorGroup = new MaskToken(true);\n\t\t\t\t\t\talternatorGroup.alternatorGroup = true;\n\t\t\t\t\t\topenenings.push(alternatorGroup);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdefaultCase();\n\t\t}\n\t}\n\n\tif (closeRegexGroup) closeGroup();\n\n\twhile (openenings.length > 0) {\n\t\topeningToken = openenings.pop();\n\t\tcurrentToken.matches.push(openingToken);\n\t}\n\tif (currentToken.matches.length > 0) {\n\t\tverifyGroupMarker(currentToken);\n\t\tmaskTokens.push(currentToken);\n\t}\n\n\tif (opts.numericInput || opts.isRTL) {\n\t\treverseTokens(maskTokens[0]);\n\t}\n\t// console.log(JSON.stringify(maskTokens));\n\treturn maskTokens;\n}\n\nmodule.exports = {\n\tgenerateMaskSet: generateMaskSet,\n\tanalyseMask: analyseMask\n};","var $ = require(\"./dependencyLibs/inputmask.dependencyLib\"), window = require(\"./global/window\"),\n\tdocument = window.document,\n\tua = window.navigator.userAgent,\n\tie = (ua.indexOf(\"MSIE \") > 0) || (ua.indexOf(\"Trident/\") > 0),\n\tmobile = isInputEventSupported(\"touchstart\"), //not entirely correct but will currently do\n\tiemobile = /iemobile/i.test(ua),\n\tiphone = /iphone/i.test(ua) && !iemobile;\n\nfunction isInputEventSupported(eventName) {\n\tvar el = document.createElement(\"input\"),\n\t\tevName = \"on\" + eventName,\n\t\tisSupported = (evName in el);\n\tif (!isSupported) {\n\t\tel.setAttribute(evName, \"return;\");\n\t\tisSupported = typeof el[evName] === \"function\";\n\t}\n\tel = null;\n\treturn isSupported;\n}\n\n//masking scope\n//actionObj definition see below\nmodule.exports = function maskScope(actionObj, maskset, opts) {\n\tmaskset = maskset || this.maskset;\n\topts = opts || this.opts;\n\n\tvar inputmask = this,\n\t\tel = this.el,\n\t\tisRTL = this.isRTL,\n\t\tundoValue,\n\t\t$el,\n\t\tskipKeyPressEvent = false, //Safari 5.1.x - modal dialog fires keypress twice workaround\n\t\tskipInputEvent = false, //skip when triggered from within inputmask\n\t\tignorable = false,\n\t\tmaxLength,\n\t\tmouseEnter = false,\n\t\tcolorMask,\n\t\toriginalPlaceholder;\n\n\t//maskset helperfunctions\n\tfunction getMaskTemplate(baseOnInput, minimalPos, includeMode, noJit, clearOptionalTail) {\n\t\t//includeMode true => input, undefined => placeholder, false => mask\n\n\t\tvar greedy = opts.greedy;\n\t\tif (clearOptionalTail) opts.greedy = false;\n\t\tminimalPos = minimalPos || 0;\n\t\tvar maskTemplate = [],\n\t\t\tndxIntlzr, pos = 0,\n\t\t\ttest, testPos;\n\t\tdo {\n\t\t\tif (baseOnInput === true && getMaskSet().validPositions[pos]) {\n\t\t\t\ttestPos = (clearOptionalTail && getMaskSet().validPositions[pos].match.optionality === true\n\t\t\t\t\t&& getMaskSet().validPositions[pos + 1] === undefined\n\t\t\t\t\t&& (getMaskSet().validPositions[pos].generatedInput === true || (getMaskSet().validPositions[pos].input == opts.skipOptionalPartCharacter && pos > 0)))\n\t\t\t\t\t? determineTestTemplate(pos, getTests(pos, ndxIntlzr, pos - 1))\n\t\t\t\t\t: getMaskSet().validPositions[pos];\n\t\t\t\ttest = testPos.match;\n\t\t\t\tndxIntlzr = testPos.locator.slice();\n\t\t\t\tmaskTemplate.push(includeMode === true ? testPos.input : includeMode === false ? test.nativeDef : getPlaceholder(pos, test));\n\t\t\t} else {\n\t\t\t\ttestPos = getTestTemplate(pos, ndxIntlzr, pos - 1);\n\t\t\t\ttest = testPos.match;\n\t\t\t\tndxIntlzr = testPos.locator.slice();\n\t\t\t\tvar jitMasking = noJit === true ? false : (opts.jitMasking !== false ? opts.jitMasking : test.jit);\n\t\t\t\tif (jitMasking === false || jitMasking === undefined /*|| pos < lvp*/ || (typeof jitMasking === \"number\" && isFinite(jitMasking) && jitMasking > pos)) {\n\t\t\t\t\tmaskTemplate.push(includeMode === false ? test.nativeDef : getPlaceholder(pos, test));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (opts.keepStatic === \"auto\") {\n\t\t\t\tif (test.newBlockMarker && test.static !== true) {\n\t\t\t\t\topts.keepStatic = pos - 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpos++;\n\t\t} while ((maxLength === undefined || pos < maxLength) && (test.static !== true || test.def !== \"\") || minimalPos > pos);\n\t\tif (maskTemplate[maskTemplate.length - 1] === \"\") {\n\t\t\tmaskTemplate.pop(); //drop the last one which is empty\n\t\t}\n\t\tif (includeMode !== false || //do not alter the masklength when just retrieving the maskdefinition\n\t\t\tgetMaskSet().maskLength === undefined) //just make sure the maskLength gets initialized in all cases (needed for isValid)\n\t\t{\n\t\t\tgetMaskSet().maskLength = pos - 1;\n\t\t}\n\n\t\topts.greedy = greedy;\n\t\treturn maskTemplate;\n\t}\n\n\tfunction getMaskSet() {\n\t\treturn maskset;\n\t}\n\n\tfunction resetMaskSet(soft) {\n\t\tvar maskset = getMaskSet();\n\t\tmaskset.buffer = undefined;\n\t\tif (soft !== true) {\n\t\t\t// maskset._buffer = undefined;\n\t\t\tmaskset.validPositions = {};\n\t\t\tmaskset.p = 0;\n\t\t}\n\t}\n\n\tfunction getLastValidPosition(closestTo, strict, validPositions) {\n\t\tvar before = -1,\n\t\t\tafter = -1,\n\t\t\tvalids = validPositions || getMaskSet().validPositions; //for use in valhook ~ context switch\n\t\tif (closestTo === undefined) closestTo = -1;\n\t\tfor (var posNdx in valids) {\n\t\t\tvar psNdx = parseInt(posNdx);\n\t\t\tif (valids[psNdx] && (strict || valids[psNdx].generatedInput !== true)) {\n\t\t\t\tif (psNdx <= closestTo) before = psNdx;\n\t\t\t\tif (psNdx >= closestTo) after = psNdx;\n\t\t\t}\n\t\t}\n\t\treturn (before === -1 || before == closestTo) ? after : after == -1 ? before : (closestTo - before) < (after - closestTo) ? before : after;\n\t}\n\n\tfunction getDecisionTaker(tst) {\n\t\tvar decisionTaker = tst.locator[tst.alternation];\n\t\tif (typeof decisionTaker == \"string\" && decisionTaker.length > 0) { //no decision taken ~ take first one as decider\n\t\t\tdecisionTaker = decisionTaker.split(\",\")[0];\n\t\t}\n\t\treturn decisionTaker !== undefined ? decisionTaker.toString() : \"\";\n\t}\n\n\tfunction getLocator(tst, align) { //need to align the locators to be correct\n\t\tvar locator = (tst.alternation != undefined ? tst.mloc[getDecisionTaker(tst)] : tst.locator).join(\"\");\n\t\tif (locator !== \"\") while (locator.length < align) locator += \"0\";\n\t\treturn locator;\n\t}\n\n\tfunction determineTestTemplate(pos, tests) {\n\t\tpos = pos > 0 ? pos - 1 : 0;\n\t\tvar altTest = getTest(pos), targetLocator = getLocator(altTest), tstLocator, closest, bestMatch;\n\t\tfor (var ndx = 0; ndx < tests.length; ndx++) { //find best matching\n\t\t\tvar tst = tests[ndx];\n\t\t\ttstLocator = getLocator(tst, targetLocator.length);\n\t\t\tvar distance = Math.abs(tstLocator - targetLocator);\n\t\t\tif (closest === undefined\n\t\t\t\t|| (tstLocator !== \"\" && distance < closest)\n\t\t\t\t|| (bestMatch && !opts.greedy && bestMatch.match.optionality && bestMatch.match.newBlockMarker === \"master\" && (!tst.match.optionality || !tst.match.newBlockMarker))\n\t\t\t\t|| (bestMatch && bestMatch.match.optionalQuantifier && !tst.match.optionalQuantifier)) {\n\t\t\t\tclosest = distance;\n\t\t\t\tbestMatch = tst;\n\t\t\t}\n\t\t}\n\n\t\treturn bestMatch;\n\t}\n\n\n\tfunction getTestTemplate(pos, ndxIntlzr, tstPs) {\n\t\treturn getMaskSet().validPositions[pos] || determineTestTemplate(pos, getTests(pos, ndxIntlzr ? ndxIntlzr.slice() : ndxIntlzr, tstPs));\n\t}\n\n\tfunction getTest(pos, tests) {\n\t\tif (getMaskSet().validPositions[pos]) {\n\t\t\treturn getMaskSet().validPositions[pos];\n\t\t}\n\t\treturn (tests || getTests(pos))[0];\n\t}\n\n\tfunction positionCanMatchDefinition(pos, def) {\n\t\tvar valid = false,\n\t\t\ttests = getTests(pos);\n\t\tfor (var tndx = 0; tndx < tests.length; tndx++) {\n\t\t\tif (tests[tndx].match && tests[tndx].match.def === def) {\n\t\t\t\tvalid = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (valid === false) {\n\t\t\tif (getMaskSet().jitOffset[pos] !== undefined) {\n\t\t\t\tvalid = positionCanMatchDefinition(pos + getMaskSet().jitOffset[pos], def);\n\t\t\t}\n\t\t}\n\t\treturn valid;\n\t}\n\n\n\tfunction getTests(pos, ndxIntlzr, tstPs) {\n\t\tvar maskTokens = getMaskSet().maskToken,\n\t\t\ttestPos = ndxIntlzr ? tstPs : 0,\n\t\t\tndxInitializer = ndxIntlzr ? ndxIntlzr.slice() : [0],\n\t\t\tmatches = [],\n\t\t\tinsertStop = false,\n\t\t\tlatestMatch,\n\t\t\tcacheDependency = ndxIntlzr ? ndxIntlzr.join(\"\") : \"\";\n\n\t\tfunction resolveTestFromToken(maskToken, ndxInitializer, loopNdx, quantifierRecurse) { //ndxInitializer contains a set of indexes to speedup searches in the mtokens\n\t\t\tfunction handleMatch(match, loopNdx, quantifierRecurse) {\n\t\t\t\tfunction isFirstMatch(latestMatch, tokenGroup) {\n\t\t\t\t\tvar firstMatch = $.inArray(latestMatch, tokenGroup.matches) === 0;\n\t\t\t\t\tif (!firstMatch) {\n\t\t\t\t\t\t$.each(tokenGroup.matches, function (ndx, match) {\n\t\t\t\t\t\t\tif (match.isQuantifier === true) {\n\t\t\t\t\t\t\t\tfirstMatch = isFirstMatch(latestMatch, tokenGroup.matches[ndx - 1]);\n\t\t\t\t\t\t\t} else if (match.hasOwnProperty(\"matches\")) firstMatch = isFirstMatch(latestMatch, match);\n\t\t\t\t\t\t\tif (firstMatch) return false;\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\treturn firstMatch;\n\t\t\t\t}\n\n\t\t\t\tfunction resolveNdxInitializer(pos, alternateNdx, targetAlternation) {\n\t\t\t\t\tvar bestMatch, indexPos;\n\n\t\t\t\t\tif (getMaskSet().tests[pos] || getMaskSet().validPositions[pos]) {\n\t\t\t\t\t\t$.each(getMaskSet().tests[pos] || [getMaskSet().validPositions[pos]], function (ndx, lmnt) {\n\t\t\t\t\t\t\tif (lmnt.mloc[alternateNdx]) {\n\t\t\t\t\t\t\t\tbestMatch = lmnt;\n\t\t\t\t\t\t\t\treturn false; //break\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvar alternation = targetAlternation !== undefined ? targetAlternation : lmnt.alternation,\n\t\t\t\t\t\t\t\tndxPos = lmnt.locator[alternation] !== undefined ? lmnt.locator[alternation].toString().indexOf(alternateNdx) : -1;\n\t\t\t\t\t\t\tif ((indexPos === undefined || ndxPos < indexPos) && ndxPos !== -1) {\n\t\t\t\t\t\t\t\tbestMatch = lmnt;\n\t\t\t\t\t\t\t\tindexPos = ndxPos;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tif (bestMatch) {\n\t\t\t\t\t\tvar bestMatchAltIndex = bestMatch.locator[bestMatch.alternation];\n\t\t\t\t\t\tvar locator = bestMatch.mloc[alternateNdx] || bestMatch.mloc[bestMatchAltIndex] || bestMatch.locator;\n\t\t\t\t\t\treturn locator.slice((targetAlternation !== undefined ? targetAlternation : bestMatch.alternation) + 1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn targetAlternation !== undefined ? resolveNdxInitializer(pos, alternateNdx) : undefined;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfunction isSubsetOf(source, target) {\n\t\t\t\t\tfunction expand(pattern) {\n\t\t\t\t\t\tvar expanded = [], start = -1, end;\n\t\t\t\t\t\tfor (var i = 0, l = pattern.length; i < l; i++) {\n\t\t\t\t\t\t\tif (pattern.charAt(i) === \"-\") {\n\t\t\t\t\t\t\t\tend = pattern.charCodeAt(i + 1);\n\t\t\t\t\t\t\t\twhile (++start < end) expanded.push(String.fromCharCode(start));\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tstart = pattern.charCodeAt(i);\n\t\t\t\t\t\t\t\texpanded.push(pattern.charAt(i));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn expanded.join(\"\");\n\t\t\t\t\t}\n\n\t\t\t\t\tif (opts.regex && source.match.static !== true && target.match.static !== true) { //is regex a subset\n\t\t\t\t\t\treturn expand(target.match.def.replace(/[[\\]]/g, \"\")).indexOf(expand(source.match.def.replace(/[[\\]]/g, \"\"))) !== -1;\n\t\t\t\t\t}\n\t\t\t\t\treturn source.match.def === target.match.nativeDef;\n\t\t\t\t}\n\n\t\t\t\tfunction staticCanMatchDefinition(source, target) {\n\t\t\t\t\tvar sloc = source.locator.slice(source.alternation).join(\"\"),\n\t\t\t\t\t\ttloc = target.locator.slice(target.alternation).join(\"\"), canMatch = sloc == tloc;\n\t\t\t\t\tcanMatch = canMatch && source.match.static === true && target.match.static !== true ? target.match.fn.test(source.match.def, getMaskSet(), pos, false, opts, false) : false;\n\n\t\t\t\t\treturn canMatch;\n\t\t\t\t}\n\n\t\t\t\t//mergelocators for retrieving the correct locator match when merging\n\t\t\t\tfunction setMergeLocators(targetMatch, altMatch) {\n\t\t\t\t\tif (altMatch === undefined || (targetMatch.alternation === altMatch.alternation &&\n\t\t\t\t\t\ttargetMatch.locator[targetMatch.alternation].toString().indexOf(altMatch.locator[altMatch.alternation]) === -1)) {\n\t\t\t\t\t\ttargetMatch.mloc = targetMatch.mloc || {};\n\t\t\t\t\t\tvar locNdx = targetMatch.locator[targetMatch.alternation];\n\t\t\t\t\t\tif (locNdx === undefined) {\n\t\t\t\t\t\t\ttargetMatch.alternation = undefined;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (typeof locNdx === \"string\") locNdx = locNdx.split(\",\")[0];\n\t\t\t\t\t\t\tif (targetMatch.mloc[locNdx] === undefined) targetMatch.mloc[locNdx] = targetMatch.locator.slice();\n\t\t\t\t\t\t\tif (altMatch !== undefined) {\n\t\t\t\t\t\t\t\tfor (var ndx in altMatch.mloc) {\n\t\t\t\t\t\t\t\t\tif (typeof ndx === \"string\") ndx = ndx.split(\",\")[0];\n\t\t\t\t\t\t\t\t\tif (targetMatch.mloc[ndx] === undefined) targetMatch.mloc[ndx] = altMatch.mloc[ndx];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\ttargetMatch.locator[targetMatch.alternation] = Object.keys(targetMatch.mloc).join(\",\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tif (testPos > 500 && quantifierRecurse !== undefined) {\n\t\t\t\t\tthrow \"Inputmask: There is probably an error in your mask definition or in the code. Create an issue on github with an example of the mask you are using. \" + getMaskSet().mask;\n\t\t\t\t}\n\t\t\t\tif (testPos === pos && match.matches === undefined) {\n\t\t\t\t\tmatches.push({\n\t\t\t\t\t\t\"match\": match,\n\t\t\t\t\t\t\"locator\": loopNdx.reverse(),\n\t\t\t\t\t\t\"cd\": cacheDependency,\n\t\t\t\t\t\t\"mloc\": {}\n\t\t\t\t\t});\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (match.matches !== undefined) {\n\t\t\t\t\tif (match.isGroup && quantifierRecurse !== match) { //when a group pass along to the quantifier\n\t\t\t\t\t\tmatch = handleMatch(maskToken.matches[$.inArray(match, maskToken.matches) + 1], loopNdx, quantifierRecurse);\n\t\t\t\t\t\tif (match) return true;\n\t\t\t\t\t} else if (match.isOptional) {\n\t\t\t\t\t\tvar optionalToken = match, mtchsNdx = matches.length;\n\t\t\t\t\t\tmatch = resolveTestFromToken(match, ndxInitializer, loopNdx, quantifierRecurse);\n\t\t\t\t\t\tif (match) {\n\t\t\t\t\t\t\t//mark optionality in matches\n\t\t\t\t\t\t\t$.each(matches, function (ndx, mtch) {\n\t\t\t\t\t\t\t\tif (ndx >= mtchsNdx) {\n\t\t\t\t\t\t\t\t\tmtch.match.optionality = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tlatestMatch = matches[matches.length - 1].match;\n\t\t\t\t\t\t\tif (quantifierRecurse === undefined && isFirstMatch(latestMatch, optionalToken)) { //prevent loop see #698\n\t\t\t\t\t\t\t\tinsertStop = true; //insert a stop\n\t\t\t\t\t\t\t\ttestPos = pos; //match the position after the group\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (match.isAlternator) {\n\t\t\t\t\t\tvar alternateToken = match,\n\t\t\t\t\t\t\tmalternateMatches = [],\n\t\t\t\t\t\t\tmaltMatches,\n\t\t\t\t\t\t\tcurrentMatches = matches.slice(),\n\t\t\t\t\t\t\tloopNdxCnt = loopNdx.length;\n\t\t\t\t\t\tvar altIndex = ndxInitializer.length > 0 ? ndxInitializer.shift() : -1;\n\t\t\t\t\t\tif (altIndex === -1 || typeof altIndex === \"string\") {\n\t\t\t\t\t\t\tvar currentPos = testPos,\n\t\t\t\t\t\t\t\tndxInitializerClone = ndxInitializer.slice(),\n\t\t\t\t\t\t\t\taltIndexArr = [],\n\t\t\t\t\t\t\t\tamndx;\n\t\t\t\t\t\t\tif (typeof altIndex == \"string\") {\n\t\t\t\t\t\t\t\taltIndexArr = altIndex.split(\",\");\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfor (amndx = 0; amndx < alternateToken.matches.length; amndx++) {\n\t\t\t\t\t\t\t\t\taltIndexArr.push(amndx.toString());\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (getMaskSet().excludes[pos]) {\n\t\t\t\t\t\t\t\tvar altIndexArrClone = altIndexArr.slice();\n\t\t\t\t\t\t\t\tfor (var i = 0, el = getMaskSet().excludes[pos].length; i < el; i++) {\n\t\t\t\t\t\t\t\t\taltIndexArr.splice(altIndexArr.indexOf(getMaskSet().excludes[pos][i].toString()), 1);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (altIndexArr.length === 0) { //fully alternated => reset\n\t\t\t\t\t\t\t\t\tgetMaskSet().excludes[pos] = undefined;\n\t\t\t\t\t\t\t\t\taltIndexArr = altIndexArrClone;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (opts.keepStatic === true || (isFinite(parseInt(opts.keepStatic)) && currentPos >= opts.keepStatic)) altIndexArr = altIndexArr.slice(0, 1);\n\t\t\t\t\t\t\tvar unMatchedAlternation = false;\n\t\t\t\t\t\t\tfor (var ndx = 0; ndx < altIndexArr.length; ndx++) {\n\t\t\t\t\t\t\t\tamndx = parseInt(altIndexArr[ndx]);\n\t\t\t\t\t\t\t\tmatches = [];\n\t\t\t\t\t\t\t\t//set the correct ndxInitializer\n\t\t\t\t\t\t\t\tndxInitializer = typeof altIndex === \"string\" ? resolveNdxInitializer(testPos, amndx, loopNdxCnt) || ndxInitializerClone.slice() : ndxInitializerClone.slice();\n\t\t\t\t\t\t\t\tif (alternateToken.matches[amndx] && handleMatch(alternateToken.matches[amndx], [amndx].concat(loopNdx), quantifierRecurse)) {\n\t\t\t\t\t\t\t\t\tmatch = true;\n\t\t\t\t\t\t\t\t} else if (ndx === 0) {\n\t\t\t\t\t\t\t\t\tunMatchedAlternation = true;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tmaltMatches = matches.slice();\n\t\t\t\t\t\t\t\ttestPos = currentPos;\n\t\t\t\t\t\t\t\tmatches = [];\n\n\t\t\t\t\t\t\t\t//fuzzy merge matches\n\t\t\t\t\t\t\t\tfor (var ndx1 = 0; ndx1 < maltMatches.length; ndx1++) {\n\t\t\t\t\t\t\t\t\tvar altMatch = maltMatches[ndx1],\n\t\t\t\t\t\t\t\t\t\tdropMatch = false;\n\t\t\t\t\t\t\t\t\taltMatch.match.jit = altMatch.match.jit || unMatchedAlternation; //mark jit when there are unmatched alternations  ex: mask: \"(a|aa)\"\n\t\t\t\t\t\t\t\t\taltMatch.alternation = altMatch.alternation || loopNdxCnt;\n\t\t\t\t\t\t\t\t\tsetMergeLocators(altMatch);\n\t\t\t\t\t\t\t\t\tfor (var ndx2 = 0; ndx2 < malternateMatches.length; ndx2++) {\n\t\t\t\t\t\t\t\t\t\tvar altMatch2 = malternateMatches[ndx2];\n\t\t\t\t\t\t\t\t\t\tif (typeof altIndex !== \"string\" || (altMatch.alternation !== undefined && $.inArray(altMatch.locator[altMatch.alternation].toString(), altIndexArr) !== -1)) {\n\t\t\t\t\t\t\t\t\t\t\tif (altMatch.match.nativeDef === altMatch2.match.nativeDef) {\n\t\t\t\t\t\t\t\t\t\t\t\tdropMatch = true;\n\t\t\t\t\t\t\t\t\t\t\t\tsetMergeLocators(altMatch2, altMatch);\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t} else if (isSubsetOf(altMatch, altMatch2)) {\n\t\t\t\t\t\t\t\t\t\t\t\tif (setMergeLocators(altMatch, altMatch2)) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tdropMatch = true;\n\t\t\t\t\t\t\t\t\t\t\t\t\tmalternateMatches.splice(malternateMatches.indexOf(altMatch2), 0, altMatch);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t} else if (isSubsetOf(altMatch2, altMatch)) {\n\t\t\t\t\t\t\t\t\t\t\t\tsetMergeLocators(altMatch2, altMatch);\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t} else if (staticCanMatchDefinition(altMatch, altMatch2)) {\n\t\t\t\t\t\t\t\t\t\t\t\tif (setMergeLocators(altMatch, altMatch2)) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t//insert match above general match\n\t\t\t\t\t\t\t\t\t\t\t\t\tdropMatch = true;\n\t\t\t\t\t\t\t\t\t\t\t\t\tmalternateMatches.splice(malternateMatches.indexOf(altMatch2), 0, altMatch);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (!dropMatch) {\n\t\t\t\t\t\t\t\t\t\tmalternateMatches.push(altMatch);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tmatches = currentMatches.concat(malternateMatches);\n\t\t\t\t\t\t\ttestPos = pos;\n\t\t\t\t\t\t\tinsertStop = matches.length > 0; //insert a stopelemnt when there is an alternate - needed for non-greedy option\n\t\t\t\t\t\t\tmatch = malternateMatches.length > 0; //set correct match state\n\n\t\t\t\t\t\t\t//cloneback\n\t\t\t\t\t\t\tndxInitializer = ndxInitializerClone.slice();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tmatch = handleMatch(alternateToken.matches[altIndex] || maskToken.matches[altIndex], [altIndex].concat(loopNdx), quantifierRecurse);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (match) return true;\n\t\t\t\t\t} else if (match.isQuantifier && quantifierRecurse !== maskToken.matches[$.inArray(match, maskToken.matches) - 1]) {\n\t\t\t\t\t\tvar qt = match;\n\t\t\t\t\t\tfor (var qndx = (ndxInitializer.length > 0) ? ndxInitializer.shift() : 0; (qndx < (isNaN(qt.quantifier.max) ? qndx + 1 : qt.quantifier.max)) && testPos <= pos; qndx++) {\n\t\t\t\t\t\t\tvar tokenGroup = maskToken.matches[$.inArray(qt, maskToken.matches) - 1];\n\t\t\t\t\t\t\tmatch = handleMatch(tokenGroup, [qndx].concat(loopNdx), tokenGroup); //set the tokenGroup as quantifierRecurse marker\n\t\t\t\t\t\t\tif (match) {\n\t\t\t\t\t\t\t\t//get latest match\n\t\t\t\t\t\t\t\tlatestMatch = matches[matches.length - 1].match;\n\t\t\t\t\t\t\t\t//mark optionality\n\t\t\t\t\t\t\t\t//TODO FIX RECURSIVE QUANTIFIERS\n\t\t\t\t\t\t\t\tlatestMatch.optionalQuantifier = qndx >= qt.quantifier.min;\n\t\t\t\t\t\t\t\t// console.log(pos + \" \" + qt.quantifier.min + \" \" + latestMatch.optionalQuantifier);\n\t\t\t\t\t\t\t\tlatestMatch.jit = (qndx || 1) * tokenGroup.matches.indexOf(latestMatch) >= qt.quantifier.jit;\n\t\t\t\t\t\t\t\tif (latestMatch.optionalQuantifier && isFirstMatch(latestMatch, tokenGroup)) {\n\t\t\t\t\t\t\t\t\tinsertStop = true;\n\t\t\t\t\t\t\t\t\ttestPos = pos; //match the position after the group\n\t\t\t\t\t\t\t\t\tbreak; //stop quantifierloop && search for next possible match\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (latestMatch.jit /*&& !latestMatch.optionalQuantifier*/) {\n\t\t\t\t\t\t\t\t\t//always set jitOffset, isvalid checks when to apply\n\t\t\t\t\t\t\t\t\tgetMaskSet().jitOffset[pos] = tokenGroup.matches.length - tokenGroup.matches.indexOf(latestMatch);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmatch = resolveTestFromToken(match, ndxInitializer, loopNdx, quantifierRecurse);\n\t\t\t\t\t\tif (match) return true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ttestPos++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//the offset is set in the quantifierloop when git masking is used\n\t\t\tfor (var tndx = (ndxInitializer.length > 0 ? ndxInitializer.shift() : 0); tndx < maskToken.matches.length; tndx++) {\n\t\t\t\tif (maskToken.matches[tndx].isQuantifier !== true) {\n\t\t\t\t\tvar match = handleMatch(maskToken.matches[tndx], [tndx].concat(loopNdx), quantifierRecurse);\n\t\t\t\t\tif (match && testPos === pos) {\n\t\t\t\t\t\treturn match;\n\t\t\t\t\t} else if (testPos > pos) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction mergeLocators(pos, tests) {\n\t\t\tvar locator = [];\n\t\t\tif (!$.isArray(tests)) tests = [tests];\n\t\t\tif (tests.length > 0) {\n\t\t\t\tif (tests[0].alternation === undefined || opts.keepStatic === true) {\n\t\t\t\t\tlocator = determineTestTemplate(pos, tests.slice()).locator.slice();\n\t\t\t\t\tif (locator.length === 0) locator = tests[0].locator.slice();\n\t\t\t\t} else {\n\t\t\t\t\t$.each(tests, function (ndx, tst) {\n\t\t\t\t\t\tif (tst.def !== \"\") {\n\t\t\t\t\t\t\tif (locator.length === 0) {\n\t\t\t\t\t\t\t\tlocator = tst.locator.slice();\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfor (var i = 0; i < locator.length; i++) {\n\t\t\t\t\t\t\t\t\tif (tst.locator[i] && locator[i].toString().indexOf(tst.locator[i]) === -1) {\n\t\t\t\t\t\t\t\t\t\tlocator[i] += \",\" + tst.locator[i];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn locator;\n\t\t}\n\n\t\tif (pos > -1) {\n\t\t\tif (ndxIntlzr === undefined) { //determine index initializer\n\t\t\t\tvar previousPos = pos - 1,\n\t\t\t\t\ttest;\n\t\t\t\twhile ((test = getMaskSet().validPositions[previousPos] || getMaskSet().tests[previousPos]) === undefined && previousPos > -1) {\n\t\t\t\t\tpreviousPos--;\n\t\t\t\t}\n\t\t\t\tif (test !== undefined && previousPos > -1) {\n\t\t\t\t\tndxInitializer = mergeLocators(previousPos, test);\n\t\t\t\t\tcacheDependency = ndxInitializer.join(\"\");\n\t\t\t\t\ttestPos = previousPos;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (getMaskSet().tests[pos] && getMaskSet().tests[pos][0].cd === cacheDependency) { //cacheDependency is set on all tests, just check on the first\n\t\t\t\treturn getMaskSet().tests[pos];\n\t\t\t}\n\t\t\tfor (var mtndx = ndxInitializer.shift(); mtndx < maskTokens.length; mtndx++) {\n\t\t\t\tvar match = resolveTestFromToken(maskTokens[mtndx], ndxInitializer, [mtndx]);\n\t\t\t\tif ((match && testPos === pos) || testPos > pos) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (matches.length === 0 || insertStop) {\n\t\t\tmatches.push({\n\t\t\t\tmatch: {\n\t\t\t\t\tfn: null,\n\t\t\t\t\tstatic: true,\n\t\t\t\t\toptionality: false,\n\t\t\t\t\tcasing: null,\n\t\t\t\t\tdef: \"\",\n\t\t\t\t\tplaceholder: \"\"\n\t\t\t\t},\n\t\t\t\tlocator: [],\n\t\t\t\tmloc: {},\n\t\t\t\tcd: cacheDependency\n\t\t\t});\n\t\t}\n\n\t\tif (ndxIntlzr !== undefined && getMaskSet().tests[pos]) { //prioritize full tests for caching\n\t\t\treturn $.extend(true, [], matches);\n\t\t}\n\t\tgetMaskSet().tests[pos] = $.extend(true, [], matches); //set a clone to prevent overwriting some props\n\t\t// console.log(pos + \" - \" + JSON.stringify(matches));\n\t\treturn getMaskSet().tests[pos];\n\t}\n\n\tfunction getBufferTemplate() {\n\t\tif (getMaskSet()._buffer === undefined) {\n\t\t\t//generate template\n\t\t\tgetMaskSet()._buffer = getMaskTemplate(false, 1);\n\t\t\tif (getMaskSet().buffer === undefined) getMaskSet().buffer = getMaskSet()._buffer.slice();\n\t\t}\n\t\treturn getMaskSet()._buffer;\n\t}\n\n\tfunction getBuffer(noCache) {\n\t\tif (getMaskSet().buffer === undefined || noCache === true) {\n\t\t\tgetMaskSet().buffer = getMaskTemplate(true, getLastValidPosition(), true);\n\t\t\tif (getMaskSet()._buffer === undefined) getMaskSet()._buffer = getMaskSet().buffer.slice();\n\t\t}\n\t\treturn getMaskSet().buffer;\n\t}\n\n\tfunction refreshFromBuffer(start, end, buffer) {\n\t\tvar i, p;\n\t\tif (start === true) {\n\t\t\tresetMaskSet();\n\t\t\tstart = 0;\n\t\t\tend = buffer.length;\n\t\t} else {\n\t\t\tfor (i = start; i < end; i++) {\n\t\t\t\tdelete getMaskSet().validPositions[i];\n\t\t\t}\n\t\t}\n\t\tp = start;\n\t\tfor (i = start; i < end; i++) {\n\t\t\tresetMaskSet(true); //prevents clobber from the buffer\n\t\t\tif (buffer[i] !== opts.skipOptionalPartCharacter) {\n\t\t\t\tvar valResult = isValid(p, buffer[i], true, true);\n\t\t\t\tif (valResult !== false) {\n\t\t\t\t\tresetMaskSet(true);\n\t\t\t\t\tp = valResult.caret !== undefined ? valResult.caret : valResult.pos + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction casing(elem, test, pos) {\n\t\tswitch (opts.casing || test.casing) {\n\t\t\tcase \"upper\":\n\t\t\t\telem = elem.toUpperCase();\n\t\t\t\tbreak;\n\t\t\tcase \"lower\":\n\t\t\t\telem = elem.toLowerCase();\n\t\t\t\tbreak;\n\t\t\tcase \"title\":\n\t\t\t\tvar posBefore = getMaskSet().validPositions[pos - 1];\n\t\t\t\tif (pos === 0 || posBefore && posBefore.input === String.fromCharCode(Inputmask.keyCode.SPACE)) {\n\t\t\t\t\telem = elem.toUpperCase();\n\t\t\t\t} else {\n\t\t\t\t\telem = elem.toLowerCase();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif ($.isFunction(opts.casing)) {\n\t\t\t\t\tvar args = Array.prototype.slice.call(arguments);\n\t\t\t\t\targs.push(getMaskSet().validPositions);\n\t\t\t\t\telem = opts.casing.apply(this, args);\n\t\t\t\t}\n\t\t}\n\n\t\treturn elem;\n\t}\n\n\tfunction checkAlternationMatch(altArr1, altArr2, na) {\n\t\tvar altArrC = opts.greedy ? altArr2 : altArr2.slice(0, 1),\n\t\t\tisMatch = false,\n\t\t\tnaArr = na !== undefined ? na.split(\",\") : [],\n\t\t\tnaNdx;\n\n\t\t//remove no alternate indexes from alternation array\n\t\tfor (var i = 0; i < naArr.length; i++) {\n\t\t\tif ((naNdx = altArr1.indexOf(naArr[i])) !== -1) {\n\t\t\t\taltArr1.splice(naNdx, 1);\n\t\t\t}\n\t\t}\n\n\t\tfor (var alndx = 0; alndx < altArr1.length; alndx++) {\n\t\t\tif ($.inArray(altArr1[alndx], altArrC) !== -1) {\n\t\t\t\tisMatch = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn isMatch;\n\t}\n\n\tfunction alternate(pos, c, strict, fromIsValid, rAltPos) { //pos == true => generalize\n\t\tvar validPsClone = $.extend(true, {}, getMaskSet().validPositions),\n\t\t\tlastAlt,\n\t\t\talternation,\n\t\t\tisValidRslt = false,\n\t\t\taltPos, prevAltPos, i, validPos,\n\t\t\tdecisionPos,\n\t\t\tlAltPos = rAltPos !== undefined ? rAltPos : getLastValidPosition();\n\n\t\tfunction insertPosition(insert) {\n\t\t\tif (insert) {\n\t\t\t\tif (isValidRslt && c !== undefined) {\n\t\t\t\t\tvar targetLvp = getLastValidPosition(pos) + 1;\n\t\t\t\t\tfor (i = decisionPos; i < getLastValidPosition() + 1; i++) {\n\t\t\t\t\t\tvalidPos = getMaskSet().validPositions[i];\n\t\t\t\t\t\tif ((validPos === undefined || validPos.match.static == true) && i < (pos + posOffset)) {\n\t\t\t\t\t\t\tposOffset++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpos = pos + posOffset;\n\t\t\t\t\tisValidRslt = isValid(pos > targetLvp ? targetLvp : pos, c, strict, fromIsValid, true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (lAltPos === -1 && rAltPos === undefined) { //do not recurse when already paste the beginning\n\t\t\tlastAlt = 0;\n\t\t\tprevAltPos = getTest(lastAlt);\n\t\t\talternation = prevAltPos.alternation;\n\t\t} else {\n\t\t\t//find last modified alternation\n\t\t\tfor (; lAltPos >= 0; lAltPos--) {\n\t\t\t\taltPos = getMaskSet().validPositions[lAltPos];\n\t\t\t\tif (altPos && altPos.alternation !== undefined) {\n\t\t\t\t\tif (prevAltPos && prevAltPos.locator[altPos.alternation] !== altPos.locator[altPos.alternation]) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tlastAlt = lAltPos;\n\t\t\t\t\talternation = getMaskSet().validPositions[lastAlt].alternation;\n\t\t\t\t\tprevAltPos = altPos;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (alternation !== undefined) {\n\t\t\tdecisionPos = parseInt(lastAlt);\n\t\t\tgetMaskSet().excludes[decisionPos] = getMaskSet().excludes[decisionPos] || [];\n\t\t\tif (pos !== true) { //generalize\n\t\t\t\tgetMaskSet().excludes[decisionPos].push(getDecisionTaker(prevAltPos));\n\t\t\t}\n\n\t\t\tvar validInputsClone = [], staticInputsBeforePos = 0;\n\t\t\tfor (i = decisionPos; i < getLastValidPosition(undefined, true) + 1; i++) {\n\t\t\t\tvalidPos = getMaskSet().validPositions[i];\n\t\t\t\tif (validPos && validPos.generatedInput !== true /*&& /[0-9a-bA-Z]/.test(validPos.input)*/) {\n\t\t\t\t\tvalidInputsClone.push(validPos.input);\n\t\t\t\t} else if (i < pos) staticInputsBeforePos++;\n\t\t\t\tdelete getMaskSet().validPositions[i];\n\t\t\t}\n\n\t\t\twhile (getMaskSet().excludes[decisionPos] && getMaskSet().excludes[decisionPos].length < 10) {\n\t\t\t\tvar posOffset = staticInputsBeforePos * -1, //negate\n\t\t\t\t\tvalidInputs = validInputsClone.slice();\n\t\t\t\tgetMaskSet().tests[decisionPos] = undefined; //clear decisionPos\n\t\t\t\tresetMaskSet(true); //clear getbuffer\n\t\t\t\tisValidRslt = true;\n\t\t\t\tinsertPosition(pos === 0);\n\t\t\t\twhile (validInputs.length > 0) {\n\t\t\t\t\tvar input = validInputs.shift();\n\t\t\t\t\t// if (input !== opts.skipOptionalPartCharacter) {\n\t\t\t\t\tif (!(isValidRslt = isValid(isValidRslt.caret || (getLastValidPosition(undefined, true) + 1), input, false, fromIsValid, true))) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// }\n\t\t\t\t}\n\t\t\t\tinsertPosition(pos > 0);\n\t\t\t\tif (!isValidRslt) {\n\t\t\t\t\tresetMaskSet();\n\t\t\t\t\tprevAltPos = getTest(decisionPos);  //get the current decisionPos to exclude ~ needs to be before restoring the initial validation\n\t\t\t\t\t//reset & revert\n\t\t\t\t\tgetMaskSet().validPositions = $.extend(true, {}, validPsClone);\n\t\t\t\t\tif (getMaskSet().excludes[decisionPos]) {\n\t\t\t\t\t\tvar decisionTaker = getDecisionTaker(prevAltPos);\n\t\t\t\t\t\tif (getMaskSet().excludes[decisionPos].indexOf(decisionTaker) !== -1) {\n\t\t\t\t\t\t\tisValidRslt = alternate(pos, c, strict, fromIsValid, decisionPos - 1);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgetMaskSet().excludes[decisionPos].push(decisionTaker);\n\t\t\t\t\t\tfor (i = decisionPos; i < getLastValidPosition(undefined, true) + 1; i++) delete getMaskSet().validPositions[i];\n\t\t\t\t\t} else { //latest alternation\n\t\t\t\t\t\tisValidRslt = alternate(pos, c, strict, fromIsValid, decisionPos - 1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//reset alternation excludes\n\t\tgetMaskSet().excludes[decisionPos] = undefined;\n\t\treturn isValidRslt;\n\t}\n\n\tfunction isValid(pos, c, strict, fromIsValid, fromAlternate, validateOnly) { //strict true ~ no correction or autofill\n\t\tfunction isSelection(posObj) {\n\t\t\treturn isRTL ? (posObj.begin - posObj.end) > 1 || ((posObj.begin - posObj.end) === 1) :\n\t\t\t\t(posObj.end - posObj.begin) > 1 || ((posObj.end - posObj.begin) === 1);\n\t\t}\n\n\t\tstrict = strict === true; //always set a value to strict to prevent possible strange behavior in the extensions\n\n\t\tvar maskPos = pos;\n\t\tif (pos.begin !== undefined) { //position was a position object - used to handle a delete by typing over a selection\n\t\t\tmaskPos = isRTL ? pos.end : pos.begin;\n\t\t}\n\n\t\tfunction processCommandObject(commandObj) {\n\t\t\tif (commandObj !== undefined) {\n\t\t\t\tif (commandObj.remove !== undefined) { //remove position(s)\n\t\t\t\t\tif (!$.isArray(commandObj.remove)) commandObj.remove = [commandObj.remove];\n\t\t\t\t\t$.each(commandObj.remove.sort(function (a, b) {\n\t\t\t\t\t\treturn b.pos - a.pos;\n\t\t\t\t\t}), function (ndx, lmnt) {\n\t\t\t\t\t\trevalidateMask({begin: lmnt, end: lmnt + 1});\n\t\t\t\t\t});\n\t\t\t\t\tcommandObj.remove = undefined;\n\t\t\t\t}\n\t\t\t\tif (commandObj.insert !== undefined) { //insert position(s)\n\t\t\t\t\tif (!$.isArray(commandObj.insert)) commandObj.insert = [commandObj.insert];\n\t\t\t\t\t$.each(commandObj.insert.sort(function (a, b) {\n\t\t\t\t\t\treturn a.pos - b.pos;\n\t\t\t\t\t}), function (ndx, lmnt) {\n\t\t\t\t\t\tisValid(lmnt.pos, lmnt.c, lmnt.strict !== undefined ? lmnt.strict : true, lmnt.fromIsValid !== undefined ? lmnt.fromIsValid : fromIsValid);\n\t\t\t\t\t});\n\t\t\t\t\tcommandObj.insert = undefined;\n\t\t\t\t}\n\n\t\t\t\tif (commandObj.refreshFromBuffer && commandObj.buffer) {\n\t\t\t\t\tvar refresh = commandObj.refreshFromBuffer;\n\t\t\t\t\trefreshFromBuffer(refresh === true ? refresh : refresh.start, refresh.end, commandObj.buffer);\n\t\t\t\t\tcommandObj.refreshFromBuffer = undefined;\n\t\t\t\t}\n\n\t\t\t\tif (commandObj.rewritePosition !== undefined) {\n\t\t\t\t\tmaskPos = commandObj.rewritePosition;\n\t\t\t\t\tcommandObj = true;\n\t\t\t\t\tcommandObj.rewritePosition = undefined;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn commandObj;\n\t\t}\n\n\t\tfunction _isValid(position, c, strict) {\n\t\t\tvar rslt = false;\n\n\t\t\t$.each(getTests(position), function (ndx, tst) {\n\t\t\t\tvar test = tst.match;\n\t\t\t\t//make sure the buffer is set and correct\n\t\t\t\tgetBuffer(true);\n\t\t\t\t//return is false or a json object => { pos: ??, c: ??} or true\n\t\t\t\trslt = test.fn != null ?\n\t\t\t\t\ttest.fn.test(c, getMaskSet(), position, strict, opts, isSelection(pos)) : (c === test.def || c === opts.skipOptionalPartCharacter) && test.def !== \"\" ? //non mask\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tc: getPlaceholder(position, test, true) || test.def,\n\t\t\t\t\t\t\tpos: position\n\t\t\t\t\t\t} : false;\n\n\t\t\t\tif (rslt !== false) {\n\t\t\t\t\tvar elem = rslt.c !== undefined ? rslt.c : c, validatedPos = position;\n\t\t\t\t\telem = (elem === opts.skipOptionalPartCharacter && test.static === true) ?\n\t\t\t\t\t\t(getPlaceholder(position, test, true) || test.def) : elem;\n\n\t\t\t\t\trslt = processCommandObject(rslt);\n\n\t\t\t\t\tif (rslt !== true && rslt.pos !== undefined && rslt.pos !== position) { //their is a position offset\n\t\t\t\t\t\tvalidatedPos = rslt.pos;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (rslt !== true && rslt.pos === undefined && rslt.c === undefined) {\n\t\t\t\t\t\treturn false; //breakout if nothing to insert\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!revalidateMask(pos, $.extend({}, tst, {\n\t\t\t\t\t\t\"input\": casing(elem, test, validatedPos)\n\t\t\t\t\t}), fromIsValid, validatedPos)) {\n\t\t\t\t\t\trslt = false;\n\t\t\t\t\t}\n\t\t\t\t\treturn false; //break from $.each\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn rslt;\n\t\t}\n\n\t\tvar result = true,\n\t\t\tpositionsClone = $.extend(true, {}, getMaskSet().validPositions); //clone the currentPositions\n\n\t\tif ($.isFunction(opts.preValidation) && !strict && fromIsValid !== true && validateOnly !== true) {\n\t\t\tresult = opts.preValidation(getBuffer(), maskPos, c, isSelection(pos), opts, getMaskSet());\n\t\t\tresult = processCommandObject(result);\n\t\t}\n\t\tif (result === true) { //preValidation result\n\t\t\tif (maxLength === undefined || maskPos < maxLength) {\n\t\t\t\tresult = _isValid(maskPos, c, strict);\n\t\t\t\t// console.log(maskPos + \" \" + c + \" \" + JSON.stringify(getMaskSet().jitOffset))\n\t\t\t\tif ((!strict || fromIsValid === true) && result === false && validateOnly !== true) {\n\t\t\t\t\tvar currentPosValid = getMaskSet().validPositions[maskPos];\n\t\t\t\t\tif (currentPosValid && currentPosValid.match.static === true && (currentPosValid.match.def === c || c === opts.skipOptionalPartCharacter)) {\n\t\t\t\t\t\tresult = {\n\t\t\t\t\t\t\t\"caret\": seekNext(maskPos)\n\t\t\t\t\t\t};\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (opts.insertMode || getMaskSet().validPositions[seekNext(maskPos)] === undefined) { //does the input match on a further position?\n\t\t\t\t\t\t\tif (getMaskSet().jitOffset[maskPos] && getMaskSet().validPositions[seekNext(maskPos)] === undefined) {\n\t\t\t\t\t\t\t\tresult = isValid(maskPos + getMaskSet().jitOffset[maskPos], c, true);\n\t\t\t\t\t\t\t\tif (result !== false) {\n\t\t\t\t\t\t\t\t\tresult.caret = maskPos;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!isMask(maskPos, true)) {\n\t\t\t\t\t\t\t\tfor (var nPos = maskPos + 1, snPos = seekNext(maskPos); nPos <= snPos; nPos++) {\n\t\t\t\t\t\t\t\t\t// if (!isMask(nPos, true)) {\n\t\t\t\t\t\t\t\t\t// \tcontinue;\n\t\t\t\t\t\t\t\t\t// }\n\t\t\t\t\t\t\t\t\tresult = _isValid(nPos, c, strict);\n\t\t\t\t\t\t\t\t\tif (result !== false) {\n\t\t\t\t\t\t\t\t\t\tresult = trackbackPositions(maskPos, result.pos !== undefined ? result.pos : nPos) || result;\n\t\t\t\t\t\t\t\t\t\tmaskPos = nPos;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (result === false && opts.keepStatic !== false && (opts.regex == null || isComplete(getBuffer())) && !strict && fromAlternate !== true) { //try fuzzy alternator logic\n\t\t\t\tresult = alternate(maskPos, c, strict, fromIsValid);\n\t\t\t}\n\t\t\tif (result === true) {\n\t\t\t\tresult = {\n\t\t\t\t\t\"pos\": maskPos\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\tif ($.isFunction(opts.postValidation) && result !== false && !strict && fromIsValid !== true && validateOnly !== true) {\n\t\t\tvar postResult = opts.postValidation(getBuffer(true), pos.begin !== undefined ? (isRTL ? pos.end : pos.begin) : pos, result, opts);\n\t\t\tif (postResult !== undefined) {\n\t\t\t\tresult = postResult === true ? result : postResult;\n\t\t\t}\n\t\t}\n\n\t\tif (result && result.pos === undefined) {\n\t\t\tresult.pos = maskPos;\n\t\t}\n\n\t\tif (result === false || validateOnly === true) {\n\t\t\tresetMaskSet(true);\n\t\t\tgetMaskSet().validPositions = $.extend(true, {}, positionsClone); //revert validation changes\n\t\t} else {\n\t\t\ttrackbackPositions(undefined, maskPos, true);\n\t\t}\n\n\t\tvar endResult = processCommandObject(result);\n\t\t// console.log(\"returned result \" + JSON.stringify(endResult));\n\t\treturn endResult;\n\t}\n\n\t//fill in best positions according the current input\n\tfunction trackbackPositions(originalPos, newPos, fillOnly) {\n\t\t// console.log(\"trackbackPositions \" + originalPos + \" \" + newPos);\n\t\tif (originalPos === undefined) {\n\t\t\t//find previous valid\n\t\t\tfor (originalPos = newPos - 1; originalPos > 0; originalPos--) {\n\t\t\t\tif (getMaskSet().validPositions[originalPos]) break;\n\t\t\t}\n\t\t}\n\t\tfor (var ps = originalPos; ps < newPos; ps++) {\n\t\t\tif (getMaskSet().validPositions[ps] === undefined && !isMask(ps, true)) {\n\t\t\t\tvar vp = ps == 0 ? getTest(ps) : getMaskSet().validPositions[ps - 1];\n\t\t\t\tif (vp) {\n\t\t\t\t\tvar tests = getTests(ps).slice();\n\t\t\t\t\tif (tests[tests.length - 1].match.def === \"\") tests.pop();\n\t\t\t\t\tvar bestMatch = determineTestTemplate(ps, tests), np;\n\t\t\t\t\tif (bestMatch && (bestMatch.match.jit !== true || (bestMatch.match.newBlockMarker === \"master\" && (np = getMaskSet().validPositions[ps + 1]) && np.match.optionalQuantifier === true))) {\n\t\t\t\t\t\tbestMatch = $.extend({}, bestMatch, {\n\t\t\t\t\t\t\t\"input\": getPlaceholder(ps, bestMatch.match, true) || bestMatch.match.def\n\t\t\t\t\t\t});\n\t\t\t\t\t\tbestMatch.generatedInput = true;\n\t\t\t\t\t\trevalidateMask(ps, bestMatch, true);\n\n\t\t\t\t\t\tif (fillOnly !== true) {\n\t\t\t\t\t\t\t//revalidate the new position to update the locator value\n\t\t\t\t\t\t\tvar cvpInput = getMaskSet().validPositions[newPos].input;\n\t\t\t\t\t\t\tgetMaskSet().validPositions[newPos] = undefined;\n\t\t\t\t\t\t\treturn isValid(newPos, cvpInput, true, true);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction revalidateMask(pos, validTest, fromIsValid, validatedPos) {\n\t\tfunction IsEnclosedStatic(pos, valids, selection) {\n\t\t\tvar posMatch = valids[pos];\n\t\t\tif (posMatch !== undefined && ((posMatch.match.static === true && posMatch.match.optionality !== true) || posMatch.input === opts.radixPoint)) {\n\t\t\t\tvar prevMatch = selection.begin <= pos - 1 ? valids[pos - 1] && valids[pos - 1].match.static === true && valids[pos - 1] : valids[pos - 1],\n\t\t\t\t\tnextMatch = selection.end > pos + 1 ? valids[pos + 1] && valids[pos + 1].match.static === true && valids[pos + 1] : valids[pos + 1];\n\t\t\t\treturn prevMatch && nextMatch;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tvar begin = pos.begin !== undefined ? pos.begin : pos, end = pos.end !== undefined ? pos.end : pos;\n\t\tif (pos.begin > pos.end) {\n\t\t\tbegin = pos.end;\n\t\t\tend = pos.begin;\n\t\t}\n\t\tvalidatedPos = validatedPos !== undefined ? validatedPos : begin;\n\t\tif (begin !== end || (opts.insertMode && getMaskSet().validPositions[validatedPos] !== undefined && fromIsValid === undefined)) {\n\t\t\t//reposition & revalidate others\n\t\t\tvar positionsClone = $.extend(true, {}, getMaskSet().validPositions),\n\t\t\t\tlvp = getLastValidPosition(undefined, true),\n\t\t\t\ti;\n\t\t\tgetMaskSet().p = begin; //needed for alternated position after overtype selection\n\n\t\t\tfor (i = lvp; i >= begin; i--) {\n\t\t\t\tdelete getMaskSet().validPositions[i];\n\t\t\t}\n\n\t\t\tvar valid = true, j = validatedPos,\n\t\t\t\tneedsValidation = false, posMatch = j;\n\t\t\ti = j;\n\n\t\t\tif (validTest) {\n\t\t\t\tgetMaskSet().validPositions[validatedPos] = $.extend(true, {}, validTest);\n\t\t\t\tposMatch++;\n\t\t\t\tj++;\n\t\t\t\tif (begin < end) i++; //if selection and entry move start by one\n\t\t\t}\n\t\t\tfor (; i <= lvp; i++) {\n\t\t\t\tvar t = positionsClone[i];\n\t\t\t\tif (t !== undefined &&\n\t\t\t\t\t(i >= end || (i >= begin && t.generatedInput !== true && IsEnclosedStatic(i, positionsClone, {\n\t\t\t\t\t\tbegin: begin,\n\t\t\t\t\t\tend: end\n\t\t\t\t\t})))) {\n\t\t\t\t\twhile (getTest(posMatch).match.def !== \"\") { //loop needed to match further positions\n\t\t\t\t\t\tif (needsValidation === false && positionsClone[posMatch] && positionsClone[posMatch].match.nativeDef === t.match.nativeDef) { //obvious match\n\t\t\t\t\t\t\tgetMaskSet().validPositions[posMatch] = $.extend(true, {}, positionsClone[posMatch]);\n\t\t\t\t\t\t\tgetMaskSet().validPositions[posMatch].input = t.input;\n\t\t\t\t\t\t\ttrackbackPositions(undefined, posMatch, true);\n\t\t\t\t\t\t\tj = posMatch + 1;\n\t\t\t\t\t\t\tvalid = true;\n\t\t\t\t\t\t} else if (opts.shiftPositions && positionCanMatchDefinition(posMatch, t.match.def)) { //validated match\n\t\t\t\t\t\t\tvar result = isValid(posMatch, t.input, true, true);\n\t\t\t\t\t\t\tvalid = result !== false;\n\t\t\t\t\t\t\t// console.log(\"match \" + posMatch + \" \" + t.input + \" \" + JSON.stringify(result));\n\t\t\t\t\t\t\t// j = (result.caret || result.insert) ? getLastValidPosition() : (result.pos || posMatch) + 1;\n\t\t\t\t\t\t\tj = (result.pos || posMatch) + 1;\n\t\t\t\t\t\t\tneedsValidation = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tvalid = t.generatedInput === true /*|| (t.input === opts.radixPoint && opts.numericInput === true)*/;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (valid) break;\n\t\t\t\t\t\tif (!valid && posMatch > end && isMask(posMatch, true) && (t.match.static !== true || posMatch > getMaskSet().maskLength)) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tposMatch++;\n\t\t\t\t\t}\n\t\t\t\t\tif (getTest(posMatch).match.def == \"\") {\n\t\t\t\t\t\tvalid = false;\n\t\t\t\t\t}\n\t\t\t\t\t//restore position\n\t\t\t\t\tposMatch = j;\n\t\t\t\t}\n\t\t\t\tif (!valid) break;\n\t\t\t}\n\n\t\t\tif (!valid) {\n\t\t\t\tgetMaskSet().validPositions = $.extend(true, {}, positionsClone);\n\t\t\t\tresetMaskSet(true);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else if (validTest) {\n\t\t\tgetMaskSet().validPositions[validatedPos] = $.extend(true, {}, validTest);\n\t\t}\n\n\n\t\tresetMaskSet(true);\n\t\treturn true;\n\t}\n\n\tfunction isMask(pos, strict) {\n\t\tvar test = getTestTemplate(pos).match;\n\t\tif (test.def === \"\") test = getTest(pos).match;\n\n\t\tif (test.static != true) {\n\t\t\treturn test.fn;\n\t\t}\n\t\tif (strict !== true && pos > -1) {\n\t\t\tvar tests = getTests(pos);\n\t\t\treturn tests.length > 1 + (tests[tests.length - 1].match.def === \"\" ? 1 : 0);\n\t\t}\n\t\treturn false;\n\t}\n\n\tfunction seekNext(pos, newBlock) {\n\t\tvar position = pos + 1;\n\t\twhile (getTest(position).match.def !== \"\" &&\n\t\t((newBlock === true && (getTest(position).match.newBlockMarker !== true || !isMask(position))) ||\n\t\t\t(newBlock !== true && !isMask(position)))) {\n\t\t\tposition++;\n\t\t}\n\t\treturn position;\n\t}\n\n\tfunction seekPrevious(pos, newBlock) {\n\t\tvar position = pos,\n\t\t\ttests;\n\t\tif (position <= 0) return 0;\n\n\t\twhile (--position > 0 &&\n\t\t((newBlock === true && getTest(position).match.newBlockMarker !== true) ||\n\t\t\t(newBlock !== true && !isMask(position) &&\n\t\t\t\t// eslint-disable-next-line no-empty\n\t\t\t\t(tests = getTests(position), tests.length < 2 || (tests.length === 2 && tests[1].match.def === \"\"))))) {\n\t\t}\n\t\treturn position;\n\t}\n\n\tfunction writeBuffer(input, buffer, caretPos, event, triggerEvents) {\n\t\tif (event && $.isFunction(opts.onBeforeWrite)) {\n\t\t\t//    buffer = buffer.slice(); //prevent uncontrolled manipulation of the internal buffer\n\t\t\tvar result = opts.onBeforeWrite.call(inputmask, event, buffer, caretPos, opts);\n\t\t\tif (result) {\n\t\t\t\tif (result.refreshFromBuffer) {\n\t\t\t\t\tvar refresh = result.refreshFromBuffer;\n\t\t\t\t\trefreshFromBuffer(refresh === true ? refresh : refresh.start, refresh.end, result.buffer || buffer);\n\t\t\t\t\tbuffer = getBuffer(true);\n\t\t\t\t}\n\t\t\t\tif (caretPos !== undefined) caretPos = result.caret !== undefined ? result.caret : caretPos;\n\t\t\t}\n\t\t}\n\t\tif (input !== undefined) {\n\t\t\tinput.inputmask._valueSet(buffer.join(\"\"));\n\t\t\tif (caretPos !== undefined && (event === undefined || event.type !== \"blur\")) {\n\t\t\t\tcaret(input, caretPos);\n\t\t\t} else {\n\t\t\t\trenderColorMask(input, caretPos, buffer.length === 0);\n\t\t\t}\n\t\t\tif (triggerEvents === true) {\n\t\t\t\tvar $input = $(input), nptVal = input.inputmask._valueGet();\n\t\t\t\tskipInputEvent = true;\n\t\t\t\t$input.trigger(\"input\");\n\t\t\t\tsetTimeout(function () { //timeout needed for IE\n\t\t\t\t\tif (nptVal === getBufferTemplate().join(\"\")) {\n\t\t\t\t\t\t$input.trigger(\"cleared\");\n\t\t\t\t\t} else if (isComplete(buffer) === true) {\n\t\t\t\t\t\t$input.trigger(\"complete\");\n\t\t\t\t\t}\n\t\t\t\t}, 0);\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction getPlaceholder(pos, test, returnPL) {\n\t\ttest = test || getTest(pos).match;\n\t\tif (test.placeholder !== undefined || returnPL === true) {\n\t\t\treturn $.isFunction(test.placeholder) ? test.placeholder(opts) : test.placeholder;\n\t\t} else if (test.static === true) {\n\t\t\tif (pos > -1 && getMaskSet().validPositions[pos] === undefined) {\n\t\t\t\tvar tests = getTests(pos),\n\t\t\t\t\tstaticAlternations = [],\n\t\t\t\t\tprevTest;\n\t\t\t\tif (tests.length > 1 + (tests[tests.length - 1].match.def === \"\" ? 1 : 0)) {\n\t\t\t\t\tfor (var i = 0; i < tests.length; i++) {\n\t\t\t\t\t\tif (tests[i].match.optionality !== true && tests[i].match.optionalQuantifier !== true &&\n\t\t\t\t\t\t\t(tests[i].match.static === true || (prevTest === undefined || tests[i].match.fn.test(prevTest.match.def, getMaskSet(), pos, true, opts) !== false))) {\n\t\t\t\t\t\t\tstaticAlternations.push(tests[i]);\n\t\t\t\t\t\t\tif (tests[i].match.static === true) prevTest = tests[i];\n\t\t\t\t\t\t\tif (staticAlternations.length > 1) {\n\t\t\t\t\t\t\t\tif (/[0-9a-bA-Z]/.test(staticAlternations[0].match.def)) {\n\t\t\t\t\t\t\t\t\treturn opts.placeholder.charAt(pos % opts.placeholder.length);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn test.def;\n\t\t}\n\n\t\treturn opts.placeholder.charAt(pos % opts.placeholder.length);\n\t}\n\n\tfunction HandleNativePlaceholder(npt, value) {\n\t\tif (ie) {\n\t\t\tif (npt.inputmask._valueGet() !== value && (npt.placeholder !== value || npt.placeholder === \"\")) {\n\t\t\t\tvar buffer = getBuffer().slice(),\n\t\t\t\t\tnptValue = npt.inputmask._valueGet();\n\t\t\t\tif (nptValue !== value) {\n\t\t\t\t\tvar lvp = getLastValidPosition();\n\t\t\t\t\tif (lvp === -1 && nptValue === getBufferTemplate().join(\"\")) {\n\t\t\t\t\t\tbuffer = [];\n\t\t\t\t\t} else if (lvp !== -1) { //clearout optional tail of the mask\n\t\t\t\t\t\tclearOptionalTail(buffer);\n\t\t\t\t\t}\n\t\t\t\t\twriteBuffer(npt, buffer);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (npt.placeholder !== value) {\n\t\t\tnpt.placeholder = value;\n\t\t\tif (npt.placeholder === \"\") npt.removeAttribute(\"placeholder\");\n\t\t}\n\t}\n\n\tfunction determineNewCaretPosition(selectedCaret, tabbed) {\n\t\tfunction doRadixFocus(clickPos) {\n\t\t\tif (opts.radixPoint !== \"\") {\n\t\t\t\tvar vps = getMaskSet().validPositions;\n\t\t\t\tif (vps[clickPos] === undefined || (vps[clickPos].input === getPlaceholder(clickPos))) {\n\t\t\t\t\tif (clickPos < seekNext(-1)) return true;\n\t\t\t\t\tvar radixPos = $.inArray(opts.radixPoint, getBuffer());\n\t\t\t\t\tif (radixPos !== -1) {\n\t\t\t\t\t\tfor (var vp in vps) {\n\t\t\t\t\t\t\tif (vps[vp] && radixPos < vp && vps[vp].input !== getPlaceholder(vp)) {\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tif (tabbed) {\n\t\t\tif (isRTL) {\n\t\t\t\tselectedCaret.end = selectedCaret.begin;\n\t\t\t} else {\n\t\t\t\tselectedCaret.begin = selectedCaret.end;\n\t\t\t}\n\t\t}\n\t\tif (selectedCaret.begin === selectedCaret.end) {\n\t\t\tswitch (opts.positionCaretOnClick) {\n\t\t\t\tcase \"none\":\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"select\":\n\t\t\t\t\treturn {begin: 0, end: getBuffer().length};\n\t\t\t\tcase \"ignore\":\n\t\t\t\t\treturn seekNext(getLastValidPosition());\n\t\t\t\tcase \"radixFocus\":\n\t\t\t\t\tif (doRadixFocus(selectedCaret.begin)) {\n\t\t\t\t\t\tvar radixPos = getBuffer().join(\"\").indexOf(opts.radixPoint);\n\t\t\t\t\t\treturn opts.numericInput ? seekNext(radixPos) : radixPos;\n\t\t\t\t\t} //fallback to lvp\n\t\t\t\t// eslint-disable-next-line no-fallthrough\n\t\t\t\tdefault: //lvp:\n\t\t\t\t\tvar clickPosition = selectedCaret.begin,\n\t\t\t\t\t\tlvclickPosition = getLastValidPosition(clickPosition, true),\n\t\t\t\t\t\tlastPosition = seekNext((lvclickPosition === -1 && !isMask(0)) ? 0 : lvclickPosition);\n\t\t\t\t\tif (clickPosition < lastPosition) {\n\t\t\t\t\t\treturn !isMask(clickPosition, true) && !isMask(clickPosition - 1, true) ? seekNext(clickPosition) : clickPosition;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar lvp = getMaskSet().validPositions[lvclickPosition],\n\t\t\t\t\t\t\ttt = getTestTemplate(lastPosition, lvp ? lvp.match.locator : undefined, lvp),\n\t\t\t\t\t\t\tplaceholder = getPlaceholder(lastPosition, tt.match);\n\t\t\t\t\t\tif ((placeholder !== \"\" && getBuffer()[lastPosition] !== placeholder && tt.match.optionalQuantifier !== true && tt.match.newBlockMarker !== true) || (!isMask(lastPosition, opts.keepStatic) && tt.match.def === placeholder)) {\n\t\t\t\t\t\t\tvar newPos = seekNext(lastPosition);\n\t\t\t\t\t\t\tif (clickPosition >= newPos || clickPosition === lastPosition) {\n\t\t\t\t\t\t\t\tlastPosition = newPos;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn lastPosition;\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvar EventRuler = {\n\t\ton: function (input, eventName, eventHandler) {\n\t\t\tvar ev = function (e) {\n\t\t\t\tvar that = this, args;\n\t\t\t\t// console.log(e.type);\n\t\t\t\tif (that.inputmask === undefined && this.nodeName !== \"FORM\") { //happens when cloning an object with jquery.clone\n\t\t\t\t\tvar imOpts = $.data(that, \"_inputmask_opts\");\n\t\t\t\t\tif (imOpts) {\n\t\t\t\t\t\t(new Inputmask(imOpts)).mask(that);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tEventRuler.off(that);\n\t\t\t\t\t}\n\t\t\t\t} else if (e.type !== \"setvalue\" && this.nodeName !== \"FORM\" && (that.disabled || (that.readOnly && !(e.type === \"keydown\" && (e.ctrlKey && e.keyCode === 67) || (opts.tabThrough === false && e.keyCode === Inputmask.keyCode.TAB))))) {\n\t\t\t\t\te.preventDefault();\n\t\t\t\t} else {\n\t\t\t\t\tswitch (e.type) {\n\t\t\t\t\t\tcase \"input\":\n\t\t\t\t\t\t\tif (skipInputEvent === true) {\n\t\t\t\t\t\t\t\tskipInputEvent = false;\n\t\t\t\t\t\t\t\treturn e.preventDefault();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (mobile) {\n\t\t\t\t\t\t\t\targs = arguments;\n\t\t\t\t\t\t\t\tsetTimeout(function () { //needed for caret selection when entering a char on Android 8 - #1818\n\t\t\t\t\t\t\t\t\teventHandler.apply(that, args);\n\t\t\t\t\t\t\t\t\tcaret(that, that.inputmask.caretPos, undefined, true);\n\t\t\t\t\t\t\t\t}, 0);\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"keydown\":\n\t\t\t\t\t\t\t//Safari 5.1.x - modal dialog fires keypress twice workaround\n\t\t\t\t\t\t\tskipKeyPressEvent = false;\n\t\t\t\t\t\t\tskipInputEvent = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"keypress\":\n\t\t\t\t\t\t\tif (skipKeyPressEvent === true) {\n\t\t\t\t\t\t\t\treturn e.preventDefault();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tskipKeyPressEvent = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"click\":\n\t\t\t\t\t\tcase \"focus\":\n\t\t\t\t\t\t\targs = arguments;\n\t\t\t\t\t\t\tsetTimeout(function () { //needed for Chrome ~ initial selection clears after the clickevent\n\t\t\t\t\t\t\t\teventHandler.apply(that, args);\n\t\t\t\t\t\t\t}, 0);\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tvar returnVal = eventHandler.apply(that, arguments);\n\t\t\t\t\tif (returnVal === false) {\n\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t\te.stopPropagation();\n\t\t\t\t\t}\n\t\t\t\t\treturn returnVal;\n\t\t\t\t}\n\t\t\t};\n\t\t\t//keep instance of the event\n\t\t\tinput.inputmask.events[eventName] = input.inputmask.events[eventName] || [];\n\t\t\tinput.inputmask.events[eventName].push(ev);\n\n\t\t\tif ($.inArray(eventName, [\"submit\", \"reset\"]) !== -1) {\n\t\t\t\tif (input.form !== null) $(input.form).on(eventName, ev);\n\t\t\t} else {\n\t\t\t\t$(input).on(eventName, ev);\n\t\t\t}\n\t\t},\n\t\toff: function (input, event) {\n\t\t\tif (input.inputmask && input.inputmask.events) {\n\t\t\t\tvar events;\n\t\t\t\tif (event) {\n\t\t\t\t\tevents = [];\n\t\t\t\t\tevents[event] = input.inputmask.events[event];\n\t\t\t\t} else {\n\t\t\t\t\tevents = input.inputmask.events;\n\t\t\t\t}\n\t\t\t\t$.each(events, function (eventName, evArr) {\n\t\t\t\t\twhile (evArr.length > 0) {\n\t\t\t\t\t\tvar ev = evArr.pop();\n\t\t\t\t\t\tif ($.inArray(eventName, [\"submit\", \"reset\"]) !== -1) {\n\t\t\t\t\t\t\tif (input.form !== null) $(input.form).off(eventName, ev);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$(input).off(eventName, ev);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdelete input.inputmask.events[eventName];\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t};\n\tvar EventHandlers = {\n\t\tkeydownEvent: function (e) {\n\t\t\tvar input = this,\n\t\t\t\t$input = $(input),\n\t\t\t\tk = e.keyCode,\n\t\t\t\tpos = caret(input);\n\n\t\t\t//backspace, delete, and escape get special treatment\n\t\t\tif (k === Inputmask.keyCode.BACKSPACE || k === Inputmask.keyCode.DELETE || (iphone && k === Inputmask.keyCode.BACKSPACE_SAFARI) || (e.ctrlKey && k === Inputmask.keyCode.X && !isInputEventSupported(\"cut\"))) { //backspace/delete\n\t\t\t\te.preventDefault(); //stop default action but allow propagation\n\t\t\t\thandleRemove(input, k, pos);\n\t\t\t\twriteBuffer(input, getBuffer(true), getMaskSet().p, e, input.inputmask._valueGet() !== getBuffer().join(\"\"));\n\t\t\t} else if (k === Inputmask.keyCode.END || k === Inputmask.keyCode.PAGE_DOWN) { //when END or PAGE_DOWN pressed set position at lastmatch\n\t\t\t\te.preventDefault();\n\t\t\t\tvar caretPos = seekNext(getLastValidPosition());\n\t\t\t\tcaret(input, e.shiftKey ? pos.begin : caretPos, caretPos, true);\n\t\t\t} else if ((k === Inputmask.keyCode.HOME && !e.shiftKey) || k === Inputmask.keyCode.PAGE_UP) { //Home or page_up\n\t\t\t\te.preventDefault();\n\t\t\t\tcaret(input, 0, e.shiftKey ? pos.begin : 0, true);\n\t\t\t} else if (((opts.undoOnEscape && k === Inputmask.keyCode.ESCAPE) || (k === 90 && e.ctrlKey)) && e.altKey !== true) { //escape && undo && #762\n\t\t\t\tcheckVal(input, true, false, undoValue.split(\"\"));\n\t\t\t\t$input.trigger(\"click\");\n\t\t\t} else if (k === Inputmask.keyCode.INSERT && !(e.shiftKey || e.ctrlKey)) { //insert\n\t\t\t\topts.insertMode = !opts.insertMode;\n\t\t\t\tinput.setAttribute(\"im-insert\", opts.insertMode);\n\t\t\t} else if (opts.tabThrough === true && k === Inputmask.keyCode.TAB) {\n\t\t\t\tif (e.shiftKey === true) {\n\t\t\t\t\tif (getTest(pos.begin).match.static === true) {\n\t\t\t\t\t\tpos.begin = seekNext(pos.begin);\n\t\t\t\t\t}\n\t\t\t\t\tpos.end = seekPrevious(pos.begin, true);\n\t\t\t\t\tpos.begin = seekPrevious(pos.end, true);\n\t\t\t\t} else {\n\t\t\t\t\tpos.begin = seekNext(pos.begin, true);\n\t\t\t\t\tpos.end = seekNext(pos.begin, true);\n\t\t\t\t\tif (pos.end < getMaskSet().maskLength) pos.end--;\n\t\t\t\t}\n\t\t\t\tif (pos.begin < getMaskSet().maskLength) {\n\t\t\t\t\te.preventDefault();\n\t\t\t\t\tcaret(input, pos.begin, pos.end);\n\t\t\t\t}\n\t\t\t}\n\t\t\topts.onKeyDown.call(this, e, getBuffer(), caret(input).begin, opts);\n\t\t\tignorable = $.inArray(k, opts.ignorables) !== -1;\n\t\t},\n\t\tkeypressEvent: function (e, checkval, writeOut, strict, ndx) {\n\t\t\tvar input = this,\n\t\t\t\t$input = $(input),\n\t\t\t\tk = e.which || e.charCode || e.keyCode;\n\n\t\t\tif (checkval !== true && (!(e.ctrlKey && e.altKey) && (e.ctrlKey || e.metaKey || ignorable))) {\n\t\t\t\tif (k === Inputmask.keyCode.ENTER && undoValue !== getBuffer().join(\"\")) {\n\t\t\t\t\tundoValue = getBuffer().join(\"\");\n\t\t\t\t\t// e.preventDefault();\n\t\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t\t$input.trigger(\"change\");\n\t\t\t\t\t}, 0);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t} else if (k) {\n\t\t\t\t//special treat the decimal separator\n\t\t\t\tif (k === 46 && e.shiftKey === false && opts.radixPoint !== \"\") k = opts.radixPoint.charCodeAt(0);\n\t\t\t\tvar pos = checkval ? {\n\t\t\t\t\t\tbegin: ndx,\n\t\t\t\t\t\tend: ndx\n\t\t\t\t\t} : caret(input),\n\t\t\t\t\tforwardPosition, c = String.fromCharCode(k);\n\n\t\t\t\tgetMaskSet().writeOutBuffer = true;\n\t\t\t\tvar valResult = isValid(pos, c, strict);\n\t\t\t\tif (valResult !== false) {\n\t\t\t\t\tresetMaskSet(true);\n\t\t\t\t\tforwardPosition = valResult.caret !== undefined ? valResult.caret : seekNext(valResult.pos.begin ? valResult.pos.begin : valResult.pos);\n\t\t\t\t\tgetMaskSet().p = forwardPosition; //needed for checkval\n\t\t\t\t}\n\n\n\t\t\t\tforwardPosition = ((opts.numericInput && valResult.caret === undefined) ? seekPrevious(forwardPosition) : forwardPosition);\n\t\t\t\tif (writeOut !== false) {\n\t\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t\topts.onKeyValidation.call(input, k, valResult, opts);\n\t\t\t\t\t}, 0);\n\t\t\t\t\tif (getMaskSet().writeOutBuffer && valResult !== false) {\n\t\t\t\t\t\tvar buffer = getBuffer();\n\t\t\t\t\t\twriteBuffer(input, buffer, forwardPosition, e, checkval !== true);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\te.preventDefault();\n\n\t\t\t\tif (checkval) {\n\t\t\t\t\tif (valResult !== false) valResult.forwardPosition = forwardPosition;\n\t\t\t\t\treturn valResult;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tpasteEvent: function (e) {\n\t\t\tvar input = this,\n\t\t\t\tev = e.originalEvent || e,\n\t\t\t\tinputValue = input.inputmask._valueGet(true),\n\t\t\t\tcaretPos = caret(input),\n\t\t\t\ttempValue;\n\n\t\t\tif (isRTL) {\n\t\t\t\ttempValue = caretPos.end;\n\t\t\t\tcaretPos.end = caretPos.begin;\n\t\t\t\tcaretPos.begin = tempValue;\n\t\t\t}\n\n\t\t\tvar valueBeforeCaret = inputValue.substr(0, caretPos.begin),\n\t\t\t\tvalueAfterCaret = inputValue.substr(caretPos.end, inputValue.length);\n\n\t\t\tif (valueBeforeCaret === (isRTL ? getBufferTemplate().reverse() : getBufferTemplate()).slice(0, caretPos.begin).join(\"\")) valueBeforeCaret = \"\";\n\t\t\tif (valueAfterCaret === (isRTL ? getBufferTemplate().reverse() : getBufferTemplate()).slice(caretPos.end).join(\"\")) valueAfterCaret = \"\";\n\n\t\t\tif (window.clipboardData && window.clipboardData.getData) { // IE\n\t\t\t\tinputValue = valueBeforeCaret + window.clipboardData.getData(\"Text\") + valueAfterCaret;\n\t\t\t} else if (ev.clipboardData && ev.clipboardData.getData) {\n\t\t\t\tinputValue = valueBeforeCaret + ev.clipboardData.getData(\"text/plain\") + valueAfterCaret;\n\t\t\t} else {\n\t\t\t\treturn true;\n\t\t\t} //allow native paste event as fallback ~ masking will continue by inputfallback\n\n\t\t\tvar pasteValue = inputValue;\n\t\t\tif ($.isFunction(opts.onBeforePaste)) {\n\t\t\t\tpasteValue = opts.onBeforePaste.call(inputmask, inputValue, opts);\n\t\t\t\tif (pasteValue === false) {\n\t\t\t\t\treturn e.preventDefault();\n\t\t\t\t}\n\t\t\t\tif (!pasteValue) {\n\t\t\t\t\tpasteValue = inputValue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcheckVal(input, false, false, pasteValue.toString().split(\"\"));\n\t\t\twriteBuffer(input, getBuffer(), seekNext(getLastValidPosition()), e, undoValue !== getBuffer().join(\"\"));\n\t\t\treturn e.preventDefault();\n\t\t},\n\t\tinputFallBackEvent: function (e) { //fallback when keypress is not triggered\n\t\t\tfunction radixPointHandler(input, inputValue, caretPos) {\n\t\t\t\t//radixpoint tweak\n\t\t\t\tif (inputValue.charAt(caretPos.begin - 1) === \".\" && opts.radixPoint !== \"\") {\n\t\t\t\t\tinputValue = inputValue.split(\"\");\n\t\t\t\t\tinputValue[caretPos.begin - 1] = opts.radixPoint.charAt(0);\n\t\t\t\t\tinputValue = inputValue.join(\"\");\n\t\t\t\t}\n\n\t\t\t\treturn inputValue;\n\t\t\t}\n\n\t\t\tfunction ieMobileHandler(input, inputValue, caretPos) {\n\t\t\t\tif (iemobile) { //iemobile just sets the character at the end althought the caret position is correctly set\n\t\t\t\t\tvar inputChar = inputValue.replace(getBuffer().join(\"\"), \"\");\n\t\t\t\t\tif (inputChar.length === 1) {\n\t\t\t\t\t\tvar iv = inputValue.split(\"\");\n\t\t\t\t\t\tiv.splice(caretPos.begin, 0, inputChar);\n\t\t\t\t\t\tinputValue = iv.join(\"\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn inputValue;\n\t\t\t}\n\n\t\t\tvar input = this,\n\t\t\t\tinputValue = input.inputmask._valueGet();\n\n\t\t\tif (getBuffer().join(\"\") !== inputValue) {\n\n\t\t\t\tvar caretPos = caret(input);\n\t\t\t\tinputValue = radixPointHandler(input, inputValue, caretPos);\n\t\t\t\tinputValue = ieMobileHandler(input, inputValue, caretPos);\n\n\t\t\t\tif (getBuffer().join(\"\") !== inputValue) {\n\t\t\t\t\tvar buffer = getBuffer().join(\"\"),\n\t\t\t\t\t\toffset = (!opts.numericInput && inputValue.length > buffer.length) ? -1 : 0,\n\t\t\t\t\t\tfrontPart = inputValue.substr(0, caretPos.begin),\n\t\t\t\t\t\tbackPart = inputValue.substr(caretPos.begin),\n\t\t\t\t\t\tfrontBufferPart = buffer.substr(0, caretPos.begin + offset),\n\t\t\t\t\t\tbackBufferPart = buffer.substr(caretPos.begin + offset);\n\n\t\t\t\t\t//check if thare was a selection\n\t\t\t\t\tvar selection = caretPos,\n\t\t\t\t\t\tentries = \"\",\n\t\t\t\t\t\tisEntry = false;\n\t\t\t\t\tif (frontPart !== frontBufferPart) {\n\t\t\t\t\t\tvar fpl = ((isEntry = frontPart.length >= frontBufferPart.length)) ? frontPart.length : frontBufferPart.length,\n\t\t\t\t\t\t\ti;\n\t\t\t\t\t\tfor (i = 0; frontPart.charAt(i) === frontBufferPart.charAt(i) && i < fpl; i++) ;\n\t\t\t\t\t\tif (isEntry) {\n\t\t\t\t\t\t\tselection.begin = i - offset;\n\t\t\t\t\t\t\tentries += frontPart.slice(i, selection.end);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (backPart !== backBufferPart) {\n\t\t\t\t\t\tif (backPart.length > backBufferPart.length) {\n\t\t\t\t\t\t\tentries += backPart.slice(0, 1);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (backPart.length < backBufferPart.length) {\n\t\t\t\t\t\t\t\tselection.end += backBufferPart.length - backPart.length;\n\t\t\t\t\t\t\t\t//hack around numeric alias & radixpoint\n\t\t\t\t\t\t\t\tif (!isEntry && opts.radixPoint !== \"\" && backPart === \"\" && frontPart.charAt(selection.begin + offset - 1) === opts.radixPoint) {\n\t\t\t\t\t\t\t\t\tselection.begin--;\n\t\t\t\t\t\t\t\t\tentries = opts.radixPoint;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\n\t\t\t\t\twriteBuffer(input, getBuffer(), {\n\t\t\t\t\t\t\"begin\": selection.begin + offset,\n\t\t\t\t\t\t\"end\": selection.end + offset\n\t\t\t\t\t});\n\t\t\t\t\tif (entries.length > 0) {\n\t\t\t\t\t\t$.each(entries.split(\"\"), function (ndx, entry) {\n\t\t\t\t\t\t\tvar keypress = new $.Event(\"keypress\");\n\t\t\t\t\t\t\tkeypress.which = entry.charCodeAt(0);\n\t\t\t\t\t\t\tignorable = false; //make sure ignorable is ignored ;-)\n\t\t\t\t\t\t\tEventHandlers.keypressEvent.call(input, keypress);\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (selection.begin === selection.end - 1) {\n\t\t\t\t\t\t\tselection.begin = seekPrevious(selection.begin + 1);\n\t\t\t\t\t\t\tif (selection.begin === selection.end - 1) {\n\t\t\t\t\t\t\t\tcaret(input, selection.begin);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcaret(input, selection.begin, selection.end);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar keydown = new $.Event(\"keydown\");\n\t\t\t\t\t\tkeydown.keyCode = opts.numericInput ? Inputmask.keyCode.BACKSPACE : Inputmask.keyCode.DELETE;\n\t\t\t\t\t\tEventHandlers.keydownEvent.call(input, keydown);\n\t\t\t\t\t}\n\n\t\t\t\t\te.preventDefault();\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tbeforeInputEvent: function (e) {\n\t\t\tif (e.cancelable) {\n\t\t\t\tvar input = this, keydown, keypress;\n\t\t\t\tswitch (e.inputType) {\n\t\t\t\t\tcase \"insertText\":\n\t\t\t\t\t\t$.each(e.data.split(\"\"), function (ndx, entry) {\n\t\t\t\t\t\t\tkeypress = new $.Event(\"keypress\");\n\t\t\t\t\t\t\tkeypress.which = entry.charCodeAt(0);\n\t\t\t\t\t\t\tignorable = false; //make sure ignorable is ignored ;-)\n\t\t\t\t\t\t\tEventHandlers.keypressEvent.call(input, keypress);\n\t\t\t\t\t\t});\n\t\t\t\t\t\treturn e.preventDefault();\n\t\t\t\t\tcase \"deleteContentBackward\":\n\t\t\t\t\t\tkeydown = new $.Event(\"keydown\");\n\t\t\t\t\t\tkeydown.keyCode = Inputmask.keyCode.BACKSPACE;\n\t\t\t\t\t\tEventHandlers.keydownEvent.call(input, keydown);\n\t\t\t\t\t\treturn e.preventDefault();\n\t\t\t\t\tcase \"deleteContentForward\":\n\t\t\t\t\t\tkeydown = new $.Event(\"keydown\");\n\t\t\t\t\t\tkeydown.keyCode = Inputmask.keyCode.DELETE;\n\t\t\t\t\t\tEventHandlers.keydownEvent.call(input, keydown);\n\t\t\t\t\t\treturn e.preventDefault();\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tsetValueEvent: function (e) {\n\t\t\tvar input = this,\n\t\t\t\tvalue = (e && e.detail) ? e.detail[0] : arguments[1];\n\t\t\tvalue = value || input.inputmask._valueGet(true);\n\n\t\t\tapplyInputValue(input, value);\n\t\t},\n\t\tfocusEvent: function (e) {\n\t\t\tvar input = this,\n\t\t\t\tnptValue = input.inputmask._valueGet();\n\t\t\tif (opts.showMaskOnFocus) {\n\t\t\t\tif (nptValue !== getBuffer().join(\"\")) {\n\t\t\t\t\twriteBuffer(input, getBuffer(), seekNext(getLastValidPosition()));\n\t\t\t\t} else if (mouseEnter === false) { //only executed on focus without mouseenter\n\t\t\t\t\tcaret(input, seekNext(getLastValidPosition()));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (opts.positionCaretOnTab === true && mouseEnter === false) {\n\t\t\t\tEventHandlers.clickEvent.apply(input, [e, true]);\n\t\t\t}\n\t\t\tundoValue = getBuffer().join(\"\");\n\t\t},\n\t\tmouseleaveEvent: function () {\n\t\t\tvar input = this;\n\t\t\tmouseEnter = false;\n\t\t\tif (opts.clearMaskOnLostFocus && document.activeElement !== input) {\n\t\t\t\tHandleNativePlaceholder(input, originalPlaceholder);\n\t\t\t}\n\t\t},\n\t\tclickEvent: function (e, tabbed) {\n\t\t\tvar input = this;\n\t\t\tif (document.activeElement === input) {\n\t\t\t\tvar newCaretPosition = determineNewCaretPosition(caret(input), tabbed);\n\t\t\t\tif (newCaretPosition !== undefined) {\n\t\t\t\t\tcaret(input, newCaretPosition);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tcutEvent: function (e) {\n\t\t\tvar input = this,\n\t\t\t\tpos = caret(input),\n\t\t\t\tev = e.originalEvent || e;\n\n\t\t\t//correct clipboardData\n\t\t\tvar clipboardData = window.clipboardData || ev.clipboardData,\n\t\t\t\tclipData = isRTL ? getBuffer().slice(pos.end, pos.begin) : getBuffer().slice(pos.begin, pos.end);\n\t\t\tclipboardData.setData(\"text\", isRTL ? clipData.reverse().join(\"\") : clipData.join(\"\"));\n\t\t\tif (document.execCommand) document.execCommand(\"copy\"); // copy selected content to system clipbaord\n\n\t\t\thandleRemove(input, Inputmask.keyCode.DELETE, pos);\n\t\t\twriteBuffer(input, getBuffer(), getMaskSet().p, e, undoValue !== getBuffer().join(\"\"));\n\t\t},\n\t\tblurEvent: function (e) {\n\t\t\tvar $input = $(this),\n\t\t\t\tinput = this;\n\t\t\tif (input.inputmask) {\n\t\t\t\tHandleNativePlaceholder(input, originalPlaceholder);\n\t\t\t\tvar nptValue = input.inputmask._valueGet(),\n\t\t\t\t\tbuffer = getBuffer().slice();\n\n\t\t\t\tif (nptValue !== \"\" || colorMask !== undefined) {\n\t\t\t\t\tif (opts.clearMaskOnLostFocus) {\n\t\t\t\t\t\tif (getLastValidPosition() === -1 && nptValue === getBufferTemplate().join(\"\")) {\n\t\t\t\t\t\t\tbuffer = [];\n\t\t\t\t\t\t} else { //clearout optional tail of the mask\n\t\t\t\t\t\t\tclearOptionalTail(buffer);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (isComplete(buffer) === false) {\n\t\t\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t\t\t$input.trigger(\"incomplete\");\n\t\t\t\t\t\t}, 0);\n\t\t\t\t\t\tif (opts.clearIncomplete) {\n\t\t\t\t\t\t\tresetMaskSet();\n\t\t\t\t\t\t\tif (opts.clearMaskOnLostFocus) {\n\t\t\t\t\t\t\t\tbuffer = [];\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tbuffer = getBufferTemplate().slice();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\twriteBuffer(input, buffer, undefined, e);\n\t\t\t\t}\n\n\t\t\t\tif (undoValue !== getBuffer().join(\"\")) {\n\t\t\t\t\tundoValue = getBuffer().join(\"\");\n\t\t\t\t\t$input.trigger(\"change\");\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tmouseenterEvent: function () {\n\t\t\tvar input = this;\n\t\t\tmouseEnter = true;\n\t\t\tif (document.activeElement !== input) {\n\t\t\t\tif(input.placeholder !== originalPlaceholder)\n\t\t\t\t\toriginalPlaceholder = input.placeholder;\n\t\t\t\tif (opts.showMaskOnHover) {\n\t\t\t\t\tHandleNativePlaceholder(input, (isRTL ? getBuffer().slice().reverse() : getBuffer()).join(\"\"));\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tsubmitEvent: function () { //trigger change on submit if any\n\t\t\tif (undoValue !== getBuffer().join(\"\")) {\n\t\t\t\t$el.trigger(\"change\");\n\t\t\t}\n\t\t\tif (opts.clearMaskOnLostFocus && getLastValidPosition() === -1 && el.inputmask._valueGet && el.inputmask._valueGet() === getBufferTemplate().join(\"\")) {\n\t\t\t\tel.inputmask._valueSet(\"\"); //clear masktemplete on submit and still has focus\n\t\t\t}\n\t\t\tif (opts.clearIncomplete && isComplete(getBuffer()) === false) {\n\t\t\t\tel.inputmask._valueSet(\"\");\n\t\t\t}\n\t\t\tif (opts.removeMaskOnSubmit) {\n\t\t\t\tel.inputmask._valueSet(el.inputmask.unmaskedvalue(), true);\n\t\t\t\tsetTimeout(function () {\n\t\t\t\t\twriteBuffer(el, getBuffer());\n\t\t\t\t}, 0);\n\t\t\t}\n\t\t},\n\t\tresetEvent: function () {\n\t\t\tel.inputmask.refreshValue = true; //indicate a forced refresh when there is a call to the value before leaving the triggering event fn\n\t\t\tsetTimeout(function () {\n\t\t\t\tapplyInputValue(el, el.inputmask._valueGet(true));\n\t\t\t}, 0);\n\t\t}\n\t};\n\n\tfunction checkVal(input, writeOut, strict, nptvl, initiatingEvent) {\n\t\tvar inputmask = this || input.inputmask,\n\t\t\tinputValue = nptvl.slice(),\n\t\t\tcharCodes = \"\",\n\t\t\tinitialNdx = -1,\n\t\t\tresult = undefined;\n\n\t\t// console.log(nptvl);\n\n\t\tfunction isTemplateMatch(ndx, charCodes) {\n\t\t\tif (opts.regex) return false;\n\t\t\tvar targetTemplate = getMaskTemplate(true, 0, false).slice(ndx, seekNext(ndx)).join(\"\").replace(/'/g, \"\"),\n\t\t\t\tcharCodeNdx = targetTemplate.indexOf(charCodes);\n\t\t\t//strip spaces from targetTemplate\n\t\t\twhile (charCodeNdx > 0 && targetTemplate[charCodeNdx - 1] === \" \") charCodeNdx--;\n\n\t\t\tvar match = charCodeNdx === 0 && !isMask(ndx)\n\t\t\t\t&& (getTest(ndx).match.nativeDef === charCodes.charAt(0)\n\t\t\t\t\t|| (getTest(ndx).match.static === true && getTest(ndx).match.nativeDef === (\"'\" + charCodes.charAt(0)))\n\t\t\t\t\t|| (getTest(ndx).match.nativeDef === \" \" && (getTest(ndx + 1).match.nativeDef === charCodes.charAt(0)\n\t\t\t\t\t\t|| (getTest(ndx + 1).match.static === true && getTest(ndx + 1).match.nativeDef === (\"'\" + charCodes.charAt(0))))));\n\n\t\t\tif (!match && charCodeNdx > 0) inputmask.caretPos = {begin: seekNext(charCodeNdx)};\n\t\t\treturn match;\n\t\t}\n\n\t\tresetMaskSet();\n\t\tinitialNdx = opts.radixPoint ? determineNewCaretPosition(0) : 0;\n\t\tgetMaskSet().p = initialNdx;\n\t\tinputmask.caretPos = {begin: initialNdx};\n\n\t\tvar staticMatches = [], prevCaretPos = inputmask.caretPos;\n\t\t$.each(inputValue, function (ndx, charCode) {\n\t\t\tif (charCode !== undefined) { //inputfallback strips some elements out of the inputarray.  $.each logically presents them as undefined\n\t\t\t\tif (getMaskSet().validPositions[ndx] === undefined && inputValue[ndx] === getPlaceholder(ndx) && isMask(ndx, true) &&\n\t\t\t\t\tisValid(ndx, inputValue[ndx], true, undefined, undefined, true) === false) {\n\t\t\t\t\tgetMaskSet().p++;\n\t\t\t\t} else {\n\t\t\t\t\tvar keypress = new $.Event(\"_checkval\");\n\t\t\t\t\tkeypress.which = charCode.charCodeAt(0);\n\t\t\t\t\tcharCodes += charCode;\n\t\t\t\t\tvar lvp = getLastValidPosition(undefined, true);\n\t\t\t\t\tif (!isTemplateMatch(initialNdx, charCodes)) {\n\t\t\t\t\t\tresult = EventHandlers.keypressEvent.call(input, keypress, true, false, strict, inputmask.caretPos.begin);\n\n\t\t\t\t\t\tif (result) {\n\t\t\t\t\t\t\tinitialNdx = inputmask.caretPos.begin + 1;\n\t\t\t\t\t\t\tcharCodes = \"\";\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult = EventHandlers.keypressEvent.call(input, keypress, true, false, strict, lvp + 1);\n\t\t\t\t\t}\n\t\t\t\t\tif (result) {\n\t\t\t\t\t\tif (result.pos && getMaskSet().validPositions[result.pos] && getMaskSet().validPositions[result.pos].match.static === true) {\n\t\t\t\t\t\t\tstaticMatches.push(result.pos);\n\t\t\t\t\t\t\tresult.forwardPosition = result.pos + 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\twriteBuffer(undefined, getBuffer(), result.forwardPosition, keypress, false);\n\t\t\t\t\t\tinputmask.caretPos = {begin: result.forwardPosition, end: result.forwardPosition};\n\t\t\t\t\t\tprevCaretPos = inputmask.caretPos;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tinputmask.caretPos = prevCaretPos;\n\t\t\t\t\t}  //restore the caret position from before the failed validation\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tif (staticMatches.length > 0) {\n\t\t\tvar sndx, validPos, nextValid;\n\t\t\tif (!isComplete(getBuffer())) {  //FIXME ENHANCE ME\n\t\t\t\twhile ((sndx = staticMatches.pop())) {\n\t\t\t\t\tvar keypress = new $.Event(\"_checkval\"),\n\t\t\t\t\t\tnextSndx = sndx + 1;\n\n\t\t\t\t\tvalidPos = getMaskSet().validPositions[sndx];\n\t\t\t\t\tvalidPos.generatedInput = true;\n\t\t\t\t\tkeypress.which = validPos.input.charCodeAt(0);\n\t\t\t\t\twhile ((nextValid = getMaskSet().validPositions[nextSndx]) && nextValid.input === validPos.input) {\n\t\t\t\t\t\tnextSndx++;\n\t\t\t\t\t}\n\t\t\t\t\tEventHandlers.keypressEvent.call(input, keypress, true, false, strict, nextSndx);\n\t\t\t\t\tif (isComplete(getBuffer())) break;\n\t\t\t\t}\n\t\t\t} else { //mark al statics as generated\n\t\t\t\twhile ((sndx = staticMatches.pop())) {\n\t\t\t\t\tvalidPos = getMaskSet().validPositions[sndx];\n\t\t\t\t\tvalidPos.generatedInput = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (writeOut) {\n\t\t\twriteBuffer(input, getBuffer(), result ? result.forwardPosition : undefined, initiatingEvent || new $.Event(\"checkval\"), initiatingEvent && initiatingEvent.type === \"input\");\n\t\t}\n\t}\n\n\tfunction unmaskedvalue(input) {\n\t\tif (input) {\n\t\t\tif (input.inputmask === undefined) {\n\t\t\t\treturn input.value;\n\t\t\t}\n\t\t\tif (input.inputmask && input.inputmask.refreshValue) { //forced refresh from the value form.reset\n\t\t\t\tapplyInputValue(input, input.inputmask._valueGet(true));\n\t\t\t}\n\t\t}\n\t\tvar umValue = [],\n\t\t\tvps = getMaskSet().validPositions;\n\t\tfor (var pndx in vps) {\n\t\t\tif (vps[pndx] && vps[pndx].match && vps[pndx].match.static != true) {\n\t\t\t\tumValue.push(vps[pndx].input);\n\t\t\t}\n\t\t}\n\t\tvar unmaskedValue = umValue.length === 0 ? \"\" : (isRTL ? umValue.reverse() : umValue).join(\"\");\n\t\tif ($.isFunction(opts.onUnMask)) {\n\t\t\tvar bufferValue = (isRTL ? getBuffer().slice().reverse() : getBuffer()).join(\"\");\n\t\t\tunmaskedValue = opts.onUnMask.call(inputmask, bufferValue, unmaskedValue, opts);\n\t\t}\n\t\treturn unmaskedValue;\n\t}\n\n\tfunction caret(input, begin, end, notranslate) {\n\t\tfunction translatePosition(pos) {\n\t\t\tif (isRTL && typeof pos === \"number\" && (!opts.greedy || opts.placeholder !== \"\") && el) {\n\t\t\t\tpos = el.inputmask._valueGet().length - pos;\n\t\t\t}\n\t\t\treturn pos;\n\t\t}\n\n\t\tvar range;\n\t\tif (begin !== undefined) {\n\t\t\tif ($.isArray(begin)) {\n\t\t\t\tend = isRTL ? begin[0] : begin[1];\n\t\t\t\tbegin = isRTL ? begin[1] : begin[0];\n\t\t\t}\n\t\t\tif (begin.begin !== undefined) {\n\t\t\t\tend = isRTL ? begin.begin : begin.end;\n\t\t\t\tbegin = isRTL ? begin.end : begin.begin;\n\t\t\t}\n\t\t\tif (typeof begin === \"number\") {\n\t\t\t\tbegin = notranslate ? begin : translatePosition(begin);\n\t\t\t\tend = notranslate ? end : translatePosition(end);\n\t\t\t\tend = (typeof end == \"number\") ? end : begin;\n\t\t\t\t// if (!$(input).is(\":visible\")) {\n\t\t\t\t// \treturn;\n\t\t\t\t// }\n\n\t\t\t\tvar scrollCalc = parseInt(((input.ownerDocument.defaultView || window).getComputedStyle ? (input.ownerDocument.defaultView || window).getComputedStyle(input, null) : input.currentStyle).fontSize) * end;\n\t\t\t\tinput.scrollLeft = scrollCalc > input.scrollWidth ? scrollCalc : 0;\n\n\t\t\t\tinput.inputmask.caretPos = {begin: begin, end: end}; //track caret internally\n\t\t\t\tif (input === document.activeElement) {\n\t\t\t\t\tif (\"setSelectionRange\" in input) {\n\t\t\t\t\t\tinput.setSelectionRange(begin, end);\n\t\t\t\t\t} else if (window.getSelection) {\n\t\t\t\t\t\trange = document.createRange();\n\t\t\t\t\t\tif (input.firstChild === undefined || input.firstChild === null) {\n\t\t\t\t\t\t\tvar textNode = document.createTextNode(\"\");\n\t\t\t\t\t\t\tinput.appendChild(textNode);\n\t\t\t\t\t\t}\n\t\t\t\t\t\trange.setStart(input.firstChild, begin < input.inputmask._valueGet().length ? begin : input.inputmask._valueGet().length);\n\t\t\t\t\t\trange.setEnd(input.firstChild, end < input.inputmask._valueGet().length ? end : input.inputmask._valueGet().length);\n\t\t\t\t\t\trange.collapse(true);\n\t\t\t\t\t\tvar sel = window.getSelection();\n\t\t\t\t\t\tsel.removeAllRanges();\n\t\t\t\t\t\tsel.addRange(range);\n\t\t\t\t\t\t//input.focus();\n\t\t\t\t\t} else if (input.createTextRange) {\n\t\t\t\t\t\trange = input.createTextRange();\n\t\t\t\t\t\trange.collapse(true);\n\t\t\t\t\t\trange.moveEnd(\"character\", end);\n\t\t\t\t\t\trange.moveStart(\"character\", begin);\n\t\t\t\t\t\trange.select();\n\t\t\t\t\t}\n\n\t\t\t\t\trenderColorMask(input, {\n\t\t\t\t\t\tbegin: begin,\n\t\t\t\t\t\tend: end\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (\"selectionStart\" in input && \"selectionEnd\" in input) {\n\t\t\t\tbegin = input.selectionStart;\n\t\t\t\tend = input.selectionEnd;\n\t\t\t} else if (window.getSelection) {\n\t\t\t\trange = window.getSelection().getRangeAt(0);\n\t\t\t\tif (range.commonAncestorContainer.parentNode === input || range.commonAncestorContainer === input) {\n\t\t\t\t\tbegin = range.startOffset;\n\t\t\t\t\tend = range.endOffset;\n\t\t\t\t}\n\t\t\t} else if (document.selection && document.selection.createRange) {\n\t\t\t\trange = document.selection.createRange();\n\t\t\t\tbegin = 0 - range.duplicate().moveStart(\"character\", -input.inputmask._valueGet().length);\n\t\t\t\tend = begin + range.text.length;\n\t\t\t}\n\n\t\t\t/*eslint-disable consistent-return */\n\t\t\treturn {\n\t\t\t\t\"begin\": notranslate ? begin : translatePosition(begin),\n\t\t\t\t\"end\": notranslate ? end : translatePosition(end)\n\t\t\t};\n\t\t\t/*eslint-enable consistent-return */\n\t\t}\n\t}\n\n\tfunction determineLastRequiredPosition(returnDefinition) {\n\t\tvar buffer = getMaskTemplate(true, getLastValidPosition(), true, true),\n\t\t\tbl = buffer.length,\n\t\t\tpos, lvp = getLastValidPosition(),\n\t\t\tpositions = {},\n\t\t\tlvTest = getMaskSet().validPositions[lvp],\n\t\t\tndxIntlzr = lvTest !== undefined ? lvTest.locator.slice() : undefined,\n\t\t\ttestPos;\n\t\tfor (pos = lvp + 1; pos < buffer.length; pos++) {\n\t\t\ttestPos = getTestTemplate(pos, ndxIntlzr, pos - 1);\n\t\t\tndxIntlzr = testPos.locator.slice();\n\t\t\tpositions[pos] = $.extend(true, {}, testPos);\n\t\t}\n\n\t\tvar lvTestAlt = lvTest && lvTest.alternation !== undefined ? lvTest.locator[lvTest.alternation] : undefined;\n\t\tfor (pos = bl - 1; pos > lvp; pos--) {\n\t\t\ttestPos = positions[pos];\n\t\t\tif ((testPos.match.optionality ||\n\t\t\t\t\t(testPos.match.optionalQuantifier && testPos.match.newBlockMarker) ||\n\t\t\t\t\t(lvTestAlt &&\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\t(lvTestAlt !== positions[pos].locator[lvTest.alternation] && testPos.match.static != true) ||\n\t\t\t\t\t\t\t(testPos.match.static === true &&\n\t\t\t\t\t\t\t\ttestPos.locator[lvTest.alternation] &&\n\t\t\t\t\t\t\t\tcheckAlternationMatch(testPos.locator[lvTest.alternation].toString().split(\",\"), lvTestAlt.toString().split(\",\")) &&\n\t\t\t\t\t\t\t\tgetTests(pos)[0].def !== \"\")\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t) &&\n\t\t\t\tbuffer[pos] === getPlaceholder(pos, testPos.match)) {\n\t\t\t\tbl--;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn returnDefinition ? {\n\t\t\t\"l\": bl,\n\t\t\t\"def\": positions[bl] ? positions[bl].match : undefined\n\t\t} : bl;\n\t}\n\n\tfunction clearOptionalTail(buffer) {\n\t\tbuffer.length = 0;\n\t\tvar template = getMaskTemplate(true, 0, true, undefined, true), lmnt;\n\t\twhile ((lmnt = template.shift()) !== undefined) buffer.push(lmnt);\n\t\treturn buffer;\n\t}\n\n\tfunction isComplete(buffer) { //return true / false / undefined (repeat *)\n\t\tif ($.isFunction(opts.isComplete)) return opts.isComplete(buffer, opts);\n\t\tif (opts.repeat === \"*\") return undefined;\n\t\tvar complete = false,\n\t\t\tlrp = determineLastRequiredPosition(true),\n\t\t\taml = seekPrevious(lrp.l);\n\n\t\tif (lrp.def === undefined || lrp.def.newBlockMarker || lrp.def.optionality || lrp.def.optionalQuantifier) {\n\t\t\tcomplete = true;\n\t\t\tfor (var i = 0; i <= aml; i++) {\n\t\t\t\tvar test = getTestTemplate(i).match;\n\t\t\t\tif ((test.static !== true && getMaskSet().validPositions[i] === undefined && test.optionality !== true && test.optionalQuantifier !== true) || (test.static === true && buffer[i] !== getPlaceholder(i, test))) {\n\t\t\t\t\tcomplete = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn complete;\n\t}\n\n\n\tfunction handleRemove(input, k, pos, strict, fromIsValid) {\n\t\tif (opts.numericInput || isRTL) {\n\t\t\tif (k === Inputmask.keyCode.BACKSPACE) {\n\t\t\t\tk = Inputmask.keyCode.DELETE;\n\t\t\t} else if (k === Inputmask.keyCode.DELETE) {\n\t\t\t\tk = Inputmask.keyCode.BACKSPACE;\n\t\t\t}\n\n\t\t\tif (isRTL) {\n\t\t\t\tvar pend = pos.end;\n\t\t\t\tpos.end = pos.begin;\n\t\t\t\tpos.begin = pend;\n\t\t\t}\n\t\t}\n\n\t\tif (k === Inputmask.keyCode.BACKSPACE && (pos.end - pos.begin < 1)) {\n\t\t\tpos.begin = seekPrevious(pos.begin);\n\t\t\tif (getMaskSet().validPositions[pos.begin] !== undefined && getMaskSet().validPositions[pos.begin].input === opts.groupSeparator) {\n\t\t\t\tpos.begin--;\n\t\t\t}\n\t\t} else if (k === Inputmask.keyCode.DELETE && pos.begin === pos.end) {\n\t\t\tpos.end = isMask(pos.end, true) && (getMaskSet().validPositions[pos.end] && getMaskSet().validPositions[pos.end].input !== opts.radixPoint) ?\n\t\t\t\tpos.end + 1 :\n\t\t\t\tseekNext(pos.end) + 1;\n\t\t\tif (getMaskSet().validPositions[pos.begin] !== undefined && getMaskSet().validPositions[pos.begin].input === opts.groupSeparator) {\n\t\t\t\tpos.end++;\n\t\t\t}\n\t\t}\n\n\t\trevalidateMask(pos);\n\n\t\tif (strict !== true && opts.keepStatic !== false || opts.regex !== null) {\n\t\t\tvar result = alternate(true);\n\t\t\tif (result) {\n\t\t\t\tvar newPos = result.caret !== undefined ? result.caret : (result.pos ? seekNext(result.pos.begin ? result.pos.begin : result.pos) : getLastValidPosition(-1, true));\n\t\t\t\tif (k !== Inputmask.keyCode.DELETE || pos.begin > newPos) {\n\t\t\t\t\tpos.begin == newPos;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvar lvp = getLastValidPosition(pos.begin, true);\n\t\tif (lvp < pos.begin || pos.begin === -1) {\n\t\t\t//if (lvp === -1) resetMaskSet();\n\t\t\tgetMaskSet().p = seekNext(lvp);\n\t\t} else if (strict !== true) {\n\t\t\tgetMaskSet().p = pos.begin;\n\t\t\tif (fromIsValid !== true) {\n\t\t\t\t//put position on first valid from pos.begin ~ #1351\n\t\t\t\twhile (getMaskSet().p < lvp && getMaskSet().validPositions[getMaskSet().p] === undefined) {\n\t\t\t\t\tgetMaskSet().p++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction initializeColorMask(input) {\n\t\tvar computedStyle = (input.ownerDocument.defaultView || window).getComputedStyle(input, null);\n\n\t\tfunction findCaretPos(clientx) {\n\t\t\t//calculate text width\n\t\t\tvar e = document.createElement(\"span\"),\n\t\t\t\tcaretPos;\n\t\t\tfor (var style in computedStyle) { //clone styles\n\t\t\t\tif (isNaN(style) && style.indexOf(\"font\") !== -1) {\n\t\t\t\t\te.style[style] = computedStyle[style];\n\t\t\t\t}\n\t\t\t}\n\t\t\te.style.textTransform = computedStyle.textTransform;\n\t\t\te.style.letterSpacing = computedStyle.letterSpacing;\n\t\t\te.style.position = \"absolute\";\n\t\t\te.style.height = \"auto\";\n\t\t\te.style.width = \"auto\";\n\t\t\te.style.visibility = \"hidden\";\n\t\t\te.style.whiteSpace = \"nowrap\";\n\n\t\t\tdocument.body.appendChild(e);\n\t\t\tvar inputText = input.inputmask._valueGet(),\n\t\t\t\tpreviousWidth = 0,\n\t\t\t\titl;\n\t\t\tfor (caretPos = 0, itl = inputText.length; caretPos <= itl; caretPos++) {\n\t\t\t\te.innerHTML += inputText.charAt(caretPos) || \"_\";\n\t\t\t\tif (e.offsetWidth >= clientx) {\n\t\t\t\t\tvar offset1 = (clientx - previousWidth);\n\t\t\t\t\tvar offset2 = e.offsetWidth - clientx;\n\t\t\t\t\te.innerHTML = inputText.charAt(caretPos);\n\t\t\t\t\toffset1 -= (e.offsetWidth / 3);\n\t\t\t\t\tcaretPos = offset1 < offset2 ? caretPos - 1 : caretPos;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpreviousWidth = e.offsetWidth;\n\t\t\t}\n\t\t\tdocument.body.removeChild(e);\n\t\t\treturn caretPos;\n\t\t}\n\n\t\tvar template = document.createElement(\"div\");\n\t\ttemplate.style.width = computedStyle.width;\n\t\ttemplate.style.textAlign = computedStyle.textAlign;\n\t\tcolorMask = document.createElement(\"div\");\n\t\tinput.inputmask.colorMask = colorMask;\n\t\tcolorMask.className = \"im-colormask\";\n\t\tinput.parentNode.insertBefore(colorMask, input);\n\t\tinput.parentNode.removeChild(input);\n\t\tcolorMask.appendChild(input);\n\t\tcolorMask.appendChild(template);\n\t\tinput.style.left = template.offsetLeft + \"px\";\n\n\t\t$(colorMask).on(\"mouseleave\", function (e) {\n\t\t\treturn EventHandlers.mouseleaveEvent.call(input, [e]);\n\t\t});\n\t\t$(colorMask).on(\"mouseenter\", function (e) {\n\t\t\treturn EventHandlers.mouseenterEvent.call(input, [e]);\n\t\t});\n\t\t$(colorMask).on(\"click\", function (e) {\n\t\t\tcaret(input, findCaretPos(e.clientX));\n\t\t\treturn EventHandlers.clickEvent.call(input, [e]);\n\t\t});\n\t}\n\n\n\tfunction renderColorMask(input, caretPos, clear) {\n\t\tvar maskTemplate = [],\n\t\t\tisStatic = false,\n\t\t\ttest, testPos, ndxIntlzr, pos = 0;\n\n\n\t\tfunction setEntry(entry) {\n\t\t\tif (entry === undefined) entry = \"\";\n\t\t\tif (!isStatic && (test.static === true || testPos.input === undefined)) {\n\t\t\t\tisStatic = true;\n\t\t\t\tmaskTemplate.push(\"<span class='im-static'>\" + entry);\n\t\t\t} else if (isStatic && ((test.static !== true && testPos.input !== undefined) || test.def === \"\")) {\n\t\t\t\tisStatic = false;\n\t\t\t\tvar mtl = maskTemplate.length;\n\t\t\t\tmaskTemplate[mtl - 1] = maskTemplate[mtl - 1] + \"</span>\";\n\t\t\t\tmaskTemplate.push(entry);\n\t\t\t} else {\n\t\t\t\tmaskTemplate.push(entry);\n\t\t\t}\n\t\t}\n\n\t\tfunction setCaret() {\n\t\t\tif (document.activeElement === input) {\n\t\t\t\tmaskTemplate.splice(caretPos.begin, 0,\n\t\t\t\t\t(caretPos.begin === caretPos.end || caretPos.end > getMaskSet().maskLength) ?\n\t\t\t\t\t\t\"<mark class=\\\"im-caret\\\" style=\\\"border-right-width: 1px;border-right-style: solid;\\\">\" :\n\t\t\t\t\t\t\"<mark class=\\\"im-caret-select\\\">\");\n\t\t\t\tmaskTemplate.splice(caretPos.end + 1, 0, \"</mark>\");\n\t\t\t}\n\t\t}\n\n\t\tif (colorMask !== undefined) {\n\t\t\tvar buffer = getBuffer();\n\t\t\tif (caretPos === undefined) {\n\t\t\t\tcaretPos = caret(input);\n\t\t\t} else if (caretPos.begin === undefined) {\n\t\t\t\tcaretPos = {\n\t\t\t\t\tbegin: caretPos,\n\t\t\t\t\tend: caretPos\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (clear !== true) {\n\t\t\t\tvar lvp = getLastValidPosition();\n\t\t\t\tdo {\n\t\t\t\t\tif (getMaskSet().validPositions[pos]) {\n\t\t\t\t\t\ttestPos = getMaskSet().validPositions[pos];\n\t\t\t\t\t\ttest = testPos.match;\n\t\t\t\t\t\tndxIntlzr = testPos.locator.slice();\n\t\t\t\t\t\tsetEntry(buffer[pos]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttestPos = getTestTemplate(pos, ndxIntlzr, pos - 1);\n\t\t\t\t\t\ttest = testPos.match;\n\t\t\t\t\t\tndxIntlzr = testPos.locator.slice();\n\t\t\t\t\t\tif (opts.jitMasking === false || pos < lvp || (typeof opts.jitMasking === \"number\" && isFinite(opts.jitMasking) && opts.jitMasking > pos)) {\n\t\t\t\t\t\t\tsetEntry(getPlaceholder(pos, test));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tisStatic = false;\n\t\t\t\t\t\t} //break infinite loop\n\t\t\t\t\t}\n\t\t\t\t\tpos++;\n\t\t\t\t} while ((maxLength === undefined || pos < maxLength) && (test.static !== true || test.def !== \"\") || lvp > pos || isStatic);\n\t\t\t\tif (isStatic) setEntry();\n\t\t\t\tsetCaret();\n\t\t\t}\n\n\t\t\tvar template = colorMask.getElementsByTagName(\"div\")[0];\n\t\t\ttemplate.innerHTML = maskTemplate.join(\"\");\n\t\t\tinput.inputmask.positionColorMask(input, template);\n\t\t}\n\t}\n\n\tfunction applyInputValue(input, value) {\n\t\tinput.inputmask.refreshValue = false;\n\t\tif ($.isFunction(opts.onBeforeMask)) value = opts.onBeforeMask.call(inputmask, value, opts) || value;\n\t\tvalue = value.toString().split(\"\");\n\t\tcheckVal(input, true, false, value);\n\t\tundoValue = getBuffer().join(\"\");\n\t\tif ((opts.clearMaskOnLostFocus || opts.clearIncomplete) && input.inputmask._valueGet() === getBufferTemplate().join(\"\")) {\n\t\t\tinput.inputmask._valueSet(\"\");\n\t\t}\n\t}\n\n\tfunction mask(elem) {\n\t\tfunction isElementTypeSupported(input, opts) {\n\t\t\tfunction patchValueProperty(npt) {\n\t\t\t\tvar valueGet;\n\t\t\t\tvar valueSet;\n\n\t\t\t\tfunction patchValhook(type) {\n\t\t\t\t\tif ($.valHooks && ($.valHooks[type] === undefined || $.valHooks[type].inputmaskpatch !== true)) {\n\t\t\t\t\t\tvar valhookGet = $.valHooks[type] && $.valHooks[type].get ? $.valHooks[type].get : function (elem) {\n\t\t\t\t\t\t\treturn elem.value;\n\t\t\t\t\t\t};\n\t\t\t\t\t\tvar valhookSet = $.valHooks[type] && $.valHooks[type].set ? $.valHooks[type].set : function (elem, value) {\n\t\t\t\t\t\t\telem.value = value;\n\t\t\t\t\t\t\treturn elem;\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t$.valHooks[type] = {\n\t\t\t\t\t\t\tget: function (elem) {\n\t\t\t\t\t\t\t\tif (elem.inputmask) {\n\t\t\t\t\t\t\t\t\tif (elem.inputmask.opts.autoUnmask) {\n\t\t\t\t\t\t\t\t\t\treturn elem.inputmask.unmaskedvalue();\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tvar result = valhookGet(elem);\n\t\t\t\t\t\t\t\t\t\treturn getLastValidPosition(undefined, undefined, elem.inputmask.maskset.validPositions) !== -1 || opts.nullable !== true ? result : \"\";\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\treturn valhookGet(elem);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tset: function (elem, value) {\n\t\t\t\t\t\t\t\tvar result = valhookSet(elem, value);\n\t\t\t\t\t\t\t\tif (elem.inputmask) {\n\t\t\t\t\t\t\t\t\tapplyInputValue(elem, value);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tinputmaskpatch: true\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfunction getter() {\n\t\t\t\t\tif (this.inputmask) {\n\t\t\t\t\t\treturn this.inputmask.opts.autoUnmask ?\n\t\t\t\t\t\t\tthis.inputmask.unmaskedvalue() :\n\t\t\t\t\t\t\t(getLastValidPosition() !== -1 || opts.nullable !== true ?\n\t\t\t\t\t\t\t\t(document.activeElement === this && opts.clearMaskOnLostFocus ?\n\t\t\t\t\t\t\t\t\t(isRTL ? clearOptionalTail(getBuffer().slice()).reverse() : clearOptionalTail(getBuffer().slice())).join(\"\") :\n\t\t\t\t\t\t\t\t\tvalueGet.call(this)) :\n\t\t\t\t\t\t\t\t\"\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn valueGet.call(this);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfunction setter(value) {\n\t\t\t\t\tvalueSet.call(this, value);\n\t\t\t\t\tif (this.inputmask) {\n\t\t\t\t\t\tapplyInputValue(this, value);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfunction installNativeValueSetFallback(npt) {\n\t\t\t\t\tEventRuler.on(npt, \"mouseenter\", function () {\n\t\t\t\t\t\tvar input = this,\n\t\t\t\t\t\t\tvalue = input.inputmask._valueGet(true);\n\t\t\t\t\t\tif (value !== (isRTL ? getBuffer().reverse() : getBuffer()).join(\"\")) { //Is this correct? to apply RTL? TOCHECK\n\t\t\t\t\t\t\tapplyInputValue(input, value);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tif (!npt.inputmask.__valueGet) {\n\t\t\t\t\tif (opts.noValuePatching !== true) {\n\t\t\t\t\t\tif (Object.getOwnPropertyDescriptor) {\n\t\t\t\t\t\t\tif (typeof Object.getPrototypeOf !== \"function\") {\n\t\t\t\t\t\t\t\tObject.getPrototypeOf = typeof \"test\".__proto__ === \"object\" ? function (object) {\n\t\t\t\t\t\t\t\t\treturn object.__proto__;\n\t\t\t\t\t\t\t\t} : function (object) {\n\t\t\t\t\t\t\t\t\treturn object.constructor.prototype;\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tvar valueProperty = Object.getPrototypeOf ? Object.getOwnPropertyDescriptor(Object.getPrototypeOf(npt), \"value\") : undefined;\n\t\t\t\t\t\t\tif (valueProperty && valueProperty.get && valueProperty.set) {\n\t\t\t\t\t\t\t\tvalueGet = valueProperty.get;\n\t\t\t\t\t\t\t\tvalueSet = valueProperty.set;\n\t\t\t\t\t\t\t\tObject.defineProperty(npt, \"value\", {\n\t\t\t\t\t\t\t\t\tget: getter,\n\t\t\t\t\t\t\t\t\tset: setter,\n\t\t\t\t\t\t\t\t\tconfigurable: true\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t} else if (npt.tagName !== \"INPUT\") {\n\t\t\t\t\t\t\t\tvalueGet = function () {\n\t\t\t\t\t\t\t\t\treturn this.textContent;\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\tvalueSet = function (value) {\n\t\t\t\t\t\t\t\t\tthis.textContent = value;\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\tObject.defineProperty(npt, \"value\", {\n\t\t\t\t\t\t\t\t\tget: getter,\n\t\t\t\t\t\t\t\t\tset: setter,\n\t\t\t\t\t\t\t\t\tconfigurable: true\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (document.__lookupGetter__ && npt.__lookupGetter__(\"value\")) {\n\t\t\t\t\t\t\tvalueGet = npt.__lookupGetter__(\"value\");\n\t\t\t\t\t\t\tvalueSet = npt.__lookupSetter__(\"value\");\n\n\t\t\t\t\t\t\tnpt.__defineGetter__(\"value\", getter);\n\t\t\t\t\t\t\tnpt.__defineSetter__(\"value\", setter);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnpt.inputmask.__valueGet = valueGet; //store native property getter\n\t\t\t\t\t\tnpt.inputmask.__valueSet = valueSet; //store native property setter\n\t\t\t\t\t}\n\t\t\t\t\tnpt.inputmask._valueGet = function (overruleRTL) {\n\t\t\t\t\t\treturn isRTL && overruleRTL !== true ? valueGet.call(this.el).split(\"\").reverse().join(\"\") : valueGet.call(this.el);\n\t\t\t\t\t};\n\t\t\t\t\tnpt.inputmask._valueSet = function (value, overruleRTL) { //null check is needed for IE8 => otherwise converts to \"null\"\n\t\t\t\t\t\tvalueSet.call(this.el, (value === null || value === undefined) ? \"\" : ((overruleRTL !== true && isRTL) ? value.split(\"\").reverse().join(\"\") : value));\n\t\t\t\t\t};\n\n\t\t\t\t\tif (valueGet === undefined) { //jquery.val fallback\n\t\t\t\t\t\tvalueGet = function () {\n\t\t\t\t\t\t\treturn this.value;\n\t\t\t\t\t\t};\n\t\t\t\t\t\tvalueSet = function (value) {\n\t\t\t\t\t\t\tthis.value = value;\n\t\t\t\t\t\t};\n\t\t\t\t\t\tpatchValhook(npt.type);\n\t\t\t\t\t\tinstallNativeValueSetFallback(npt);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar elementType = input.getAttribute(\"type\");\n\t\t\tvar isSupported = (input.tagName === \"INPUT\" && $.inArray(elementType, opts.supportsInputType) !== -1) || input.isContentEditable || input.tagName === \"TEXTAREA\";\n\t\t\tif (!isSupported) {\n\t\t\t\tif (input.tagName === \"INPUT\") {\n\t\t\t\t\tvar el = document.createElement(\"input\");\n\t\t\t\t\tel.setAttribute(\"type\", elementType);\n\t\t\t\t\tisSupported = el.type === \"text\"; //apply mask only if the type is not natively supported\n\t\t\t\t\tel = null;\n\t\t\t\t} else {\n\t\t\t\t\tisSupported = \"partial\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (isSupported !== false) {\n\t\t\t\tpatchValueProperty(input);\n\t\t\t} else {\n\t\t\t\tinput.inputmask = undefined;\n\t\t\t}\n\t\t\treturn isSupported;\n\t\t}\n\n\t\t//unbind all events - to make sure that no other mask will interfere when re-masking\n\t\tEventRuler.off(elem);\n\t\tvar isSupported = isElementTypeSupported(elem, opts);\n\t\tif (isSupported !== false) {\n\t\t\tel = elem;\n\t\t\t$el = $(el);\n\n\t\t\toriginalPlaceholder = el.placeholder;\n\n\t\t\t//read maxlength prop from el\n\t\t\tmaxLength = el !== undefined ? el.maxLength : undefined;\n\t\t\tif (maxLength === -1) maxLength = undefined;\n\n\t\t\tif (opts.colorMask === true) {\n\t\t\t\tinitializeColorMask(el);\n\t\t\t}\n\t\t\tif (mobile) {\n\t\t\t\tif (\"inputmode\" in el) {\n\t\t\t\t\tel.inputmode = opts.inputmode;\n\t\t\t\t\tel.setAttribute(\"inputmode\", opts.inputmode);\n\t\t\t\t}\n\t\t\t\tif (opts.disablePredictiveText === true) {\n\t\t\t\t\tif (\"autocorrect\" in el) {  //safari\n\t\t\t\t\t\tel.autocorrect = false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (opts.colorMask !== true) {\n\t\t\t\t\t\t\tinitializeColorMask(el);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tel.type = \"password\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (isSupported === true) {\n\t\t\t\tel.setAttribute(\"im-insert\", opts.insertMode);\n\n\t\t\t\t//bind events\n\t\t\t\tEventRuler.on(el, \"submit\", EventHandlers.submitEvent);\n\t\t\t\tEventRuler.on(el, \"reset\", EventHandlers.resetEvent);\n\t\t\t\tEventRuler.on(el, \"blur\", EventHandlers.blurEvent);\n\t\t\t\tEventRuler.on(el, \"focus\", EventHandlers.focusEvent);\n\t\t\t\tif (opts.colorMask !== true) {\n\t\t\t\t\tEventRuler.on(el, \"click\", EventHandlers.clickEvent);\n\t\t\t\t\tEventRuler.on(el, \"mouseleave\", EventHandlers.mouseleaveEvent);\n\t\t\t\t\tEventRuler.on(el, \"mouseenter\", EventHandlers.mouseenterEvent);\n\t\t\t\t}\n\t\t\t\tEventRuler.on(el, \"paste\", EventHandlers.pasteEvent);\n\t\t\t\tEventRuler.on(el, \"cut\", EventHandlers.cutEvent);\n\t\t\t\tEventRuler.on(el, \"complete\", opts.oncomplete);\n\t\t\t\tEventRuler.on(el, \"incomplete\", opts.onincomplete);\n\t\t\t\tEventRuler.on(el, \"cleared\", opts.oncleared);\n\t\t\t\tif (!mobile && opts.inputEventOnly !== true) {\n\t\t\t\t\tEventRuler.on(el, \"keydown\", EventHandlers.keydownEvent);\n\t\t\t\t\tEventRuler.on(el, \"keypress\", EventHandlers.keypressEvent);\n\t\t\t\t} else {\n\t\t\t\t\tel.removeAttribute(\"maxLength\");\n\t\t\t\t}\n\t\t\t\tEventRuler.on(el, \"input\", EventHandlers.inputFallBackEvent);\n\t\t\t\tEventRuler.on(el, \"beforeinput\", EventHandlers.beforeInputEvent); //https://github.com/w3c/input-events - to implement\n\t\t\t}\n\t\t\tEventRuler.on(el, \"setvalue\", EventHandlers.setValueEvent);\n\n\t\t\t//apply mask\n\t\t\tundoValue = getBufferTemplate().join(\"\"); //initialize the buffer and getmasklength\n\t\t\tif (el.inputmask._valueGet(true) !== \"\" || opts.clearMaskOnLostFocus === false || document.activeElement === el) {\n\t\t\t\tvar initialValue = $.isFunction(opts.onBeforeMask) ? (opts.onBeforeMask.call(inputmask, el.inputmask._valueGet(true), opts) || el.inputmask._valueGet(true)) : el.inputmask._valueGet(true);\n\t\t\t\tif (initialValue !== \"\") checkVal(el, true, false, initialValue.split(\"\"));\n\t\t\t\tvar buffer = getBuffer().slice();\n\t\t\t\tundoValue = buffer.join(\"\");\n\t\t\t\t// Wrap document.activeElement in a try/catch block since IE9 throw \"Unspecified error\" if document.activeElement is undefined when we are in an IFrame.\n\t\t\t\tif (isComplete(buffer) === false) {\n\t\t\t\t\tif (opts.clearIncomplete) {\n\t\t\t\t\t\tresetMaskSet();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (opts.clearMaskOnLostFocus && document.activeElement !== el) {\n\t\t\t\t\tif (getLastValidPosition() === -1) {\n\t\t\t\t\t\tbuffer = [];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tclearOptionalTail(buffer);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (opts.clearMaskOnLostFocus === false || (opts.showMaskOnFocus && document.activeElement === el) || el.inputmask._valueGet(true) !== \"\") {\n\t\t\t\t\twriteBuffer(el, buffer);\n\t\t\t\t}\n\t\t\t\tif (document.activeElement === el) { //position the caret when in focus\n\t\t\t\t\tcaret(el, seekNext(getLastValidPosition()));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t//action object\n\tvar valueBuffer;\n\tif (actionObj !== undefined) {\n\t\tswitch (actionObj.action) {\n\t\t\tcase \"isComplete\":\n\t\t\t\tel = actionObj.el;\n\t\t\t\treturn isComplete(getBuffer());\n\t\t\tcase \"unmaskedvalue\":\n\t\t\t\tif (el === undefined || actionObj.value !== undefined) {\n\t\t\t\t\tvalueBuffer = actionObj.value;\n\t\t\t\t\tvalueBuffer = ($.isFunction(opts.onBeforeMask) ? (opts.onBeforeMask.call(inputmask, valueBuffer, opts) || valueBuffer) : valueBuffer).split(\"\");\n\t\t\t\t\tcheckVal.call(this, undefined, false, false, valueBuffer);\n\t\t\t\t\tif ($.isFunction(opts.onBeforeWrite)) opts.onBeforeWrite.call(inputmask, undefined, getBuffer(), 0, opts);\n\t\t\t\t}\n\t\t\t\treturn unmaskedvalue(el);\n\t\t\tcase \"mask\":\n\t\t\t\tmask(el);\n\t\t\t\tbreak;\n\t\t\tcase \"format\":\n\t\t\t\tvalueBuffer = ($.isFunction(opts.onBeforeMask) ? (opts.onBeforeMask.call(inputmask, actionObj.value, opts) || actionObj.value) : actionObj.value).split(\"\");\n\t\t\t\tcheckVal.call(this, undefined, true, false, valueBuffer);\n\t\t\t\tif (actionObj.metadata) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tvalue: isRTL ? getBuffer().slice().reverse().join(\"\") : getBuffer().join(\"\"),\n\t\t\t\t\t\tmetadata: maskScope.call(this, {\n\t\t\t\t\t\t\t\"action\": \"getmetadata\"\n\t\t\t\t\t\t}, maskset, opts)\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\treturn isRTL ? getBuffer().slice().reverse().join(\"\") : getBuffer().join(\"\");\n\t\t\tcase \"isValid\":\n\t\t\t\tif (actionObj.value) {\n\t\t\t\t\tvalueBuffer = actionObj.value.split(\"\");\n\t\t\t\t\tcheckVal.call(this, undefined, true, true, valueBuffer);\n\t\t\t\t} else {\n\t\t\t\t\tactionObj.value = isRTL ? getBuffer().slice().reverse().join(\"\") : getBuffer().join(\"\");\n\t\t\t\t}\n\t\t\t\tvar buffer = getBuffer();\n\t\t\t\tvar rl = determineLastRequiredPosition(),\n\t\t\t\t\tlmib = buffer.length - 1;\n\t\t\t\tfor (; lmib > rl; lmib--) {\n\t\t\t\t\tif (isMask(lmib)) break;\n\t\t\t\t}\n\t\t\t\tbuffer.splice(rl, lmib + 1 - rl);\n\n\t\t\t\treturn isComplete(buffer) && actionObj.value === (isRTL ? getBuffer().slice().reverse().join(\"\") : getBuffer().join(\"\"));\n\t\t\tcase \"getemptymask\":\n\t\t\t\treturn getBufferTemplate().join(\"\");\n\t\t\tcase \"remove\":\n\t\t\t\tif (el && el.inputmask) {\n\t\t\t\t\t$.data(el, \"_inputmask_opts\", null); //invalidate\n\t\t\t\t\t$el = $(el);\n\t\t\t\t\t//writeout the value\n\t\t\t\t\tvar cv = opts.autoUnmask ? unmaskedvalue(el) : el.inputmask._valueGet(opts.autoUnmask);\n\t\t\t\t\tif (cv !== getBufferTemplate().join(\"\")) el.inputmask._valueSet(cv, opts.autoUnmask); else el.inputmask._valueSet(\"\");\n\t\t\t\t\t//unbind all events\n\t\t\t\t\tEventRuler.off(el);\n\t\t\t\t\t//remove colormask if used\n\t\t\t\t\tif (el.inputmask.colorMask) {\n\t\t\t\t\t\tcolorMask = el.inputmask.colorMask;\n\t\t\t\t\t\tcolorMask.removeChild(el);\n\t\t\t\t\t\tcolorMask.parentNode.insertBefore(el, colorMask);\n\t\t\t\t\t\tcolorMask.parentNode.removeChild(colorMask);\n\t\t\t\t\t}\n\t\t\t\t\t//restore the value property\n\t\t\t\t\tvar valueProperty;\n\t\t\t\t\tif (Object.getOwnPropertyDescriptor && Object.getPrototypeOf) {\n\t\t\t\t\t\tvalueProperty = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(el), \"value\");\n\t\t\t\t\t\tif (valueProperty) {\n\t\t\t\t\t\t\tif (el.inputmask.__valueGet) {\n\t\t\t\t\t\t\t\tObject.defineProperty(el, \"value\", {\n\t\t\t\t\t\t\t\t\tget: el.inputmask.__valueGet,\n\t\t\t\t\t\t\t\t\tset: el.inputmask.__valueSet,\n\t\t\t\t\t\t\t\t\tconfigurable: true\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (document.__lookupGetter__ && el.__lookupGetter__(\"value\")) {\n\t\t\t\t\t\tif (el.inputmask.__valueGet) {\n\t\t\t\t\t\t\tel.__defineGetter__(\"value\", el.inputmask.__valueGet);\n\t\t\t\t\t\t\tel.__defineSetter__(\"value\", el.inputmask.__valueSet);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//clear data\n\t\t\t\t\tel.inputmask = undefined;\n\t\t\t\t}\n\t\t\t\treturn el;\n\t\t\tcase \"getmetadata\":\n\t\t\t\tif ($.isArray(maskset.metadata)) {\n\t\t\t\t\tvar maskTarget = getMaskTemplate(true, 0, false).join(\"\");\n\t\t\t\t\t$.each(maskset.metadata, function (ndx, mtdt) {\n\t\t\t\t\t\tif (mtdt.mask === maskTarget) {\n\t\t\t\t\t\t\tmaskTarget = mtdt;\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\treturn maskTarget;\n\t\t\t\t}\n\n\t\t\t\treturn maskset.metadata;\n\t\t}\n\t}\n};\n\n","/*\n Input Mask plugin extensions\n http://github.com/RobinHerbots/jquery.inputmask\n Copyright (c) Robin Herbots\n Licensed under the MIT license\n */\nvar Inputmask = require(\"../inputmask\"), $ = Inputmask.dependencyLib,\n\t//supported codes for formatting\n\t//http://blog.stevenlevithan.com/archives/date-time-format\n\t//https://docs.microsoft.com/en-us/dotnet/standard/base-types/custom-date-and-time-format-strings?view=netframework-4.7\n\tformatCode = { //regex, valueSetter, type, displayformatter\n\t\td: [\"[1-9]|[12][0-9]|3[01]\", Date.prototype.setDate, \"day\", Date.prototype.getDate], //Day of the month as digits; no leading zero for single-digit days.\n\t\tdd: [\"0[1-9]|[12][0-9]|3[01]\", Date.prototype.setDate, \"day\", function () {\n\t\t\treturn pad(Date.prototype.getDate.call(this), 2);\n\t\t}], //Day of the month as digits; leading zero for single-digit days.\n\t\tddd: [\"\"], //Day of the week as a three-letter abbreviation.\n\t\tdddd: [\"\"], //Day of the week as its full name.\n\t\tm: [\"[1-9]|1[012]\", Date.prototype.setMonth, \"month\", function () {\n\t\t\treturn Date.prototype.getMonth.call(this) + 1;\n\t\t}], //Month as digits; no leading zero for single-digit months.\n\t\tmm: [\"0[1-9]|1[012]\", Date.prototype.setMonth, \"month\", function () {\n\t\t\treturn pad(Date.prototype.getMonth.call(this) + 1, 2);\n\t\t}], //Month as digits; leading zero for single-digit months.\n\t\tmmm: [\"\"], //Month as a three-letter abbreviation.\n\t\tmmmm: [\"\"], //Month as its full name.\n\t\tyy: [\"[0-9]{2}\", Date.prototype.setFullYear, \"year\", function () {\n\t\t\treturn pad(Date.prototype.getFullYear.call(this), 2);\n\t\t}], //Year as last two digits; leading zero for years less than 10.\n\t\tyyyy: [\"[0-9]{4}\", Date.prototype.setFullYear, \"year\", function () {\n\t\t\treturn pad(Date.prototype.getFullYear.call(this), 4);\n\t\t}],\n\t\th: [\"[1-9]|1[0-2]\", Date.prototype.setHours, \"hours\", Date.prototype.getHours], //Hours; no leading zero for single-digit hours (12-hour clock).\n\t\thh: [\"0[1-9]|1[0-2]\", Date.prototype.setHours, \"hours\", function () {\n\t\t\treturn pad(Date.prototype.getHours.call(this), 2);\n\t\t}], //Hours; leading zero for single-digit hours (12-hour clock).\n\t\thhh: [\"[0-9]+\", Date.prototype.setHours, \"hours\", Date.prototype.getHours], //Hours; no limit\n\t\tH: [\"1?[0-9]|2[0-3]\", Date.prototype.setHours, \"hours\", Date.prototype.getHours], //Hours; no leading zero for single-digit hours (24-hour clock).\n\t\tHH: [\"0[0-9]|1[0-9]|2[0-3]\", Date.prototype.setHours, \"hours\", function () {\n\t\t\treturn pad(Date.prototype.getHours.call(this), 2);\n\t\t}], //Hours; leading zero for single-digit hours (24-hour clock).\n\t\tHHH: [\"[0-9]+\", Date.prototype.setHours, \"hours\", Date.prototype.getHours], //Hours; no limit\n\t\tM: [\"[1-5]?[0-9]\", Date.prototype.setMinutes, \"minutes\", Date.prototype.getMinutes], //Minutes; no leading zero for single-digit minutes. Uppercase M unlike CF timeFormat's m to avoid conflict with months.\n\t\tMM: [\"0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]\", Date.prototype.setMinutes, \"minutes\", function () {\n\t\t\treturn pad(Date.prototype.getMinutes.call(this), 2);\n\t\t}], //Minutes; leading zero for single-digit minutes. Uppercase MM unlike CF timeFormat's mm to avoid conflict with months.\n\t\ts: [\"[1-5]?[0-9]\", Date.prototype.setSeconds, \"seconds\", Date.prototype.getSeconds], //Seconds; no leading zero for single-digit seconds.\n\t\tss: [\"0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]\", Date.prototype.setSeconds, \"seconds\", function () {\n\t\t\treturn pad(Date.prototype.getSeconds.call(this), 2);\n\t\t}], //Seconds; leading zero for single-digit seconds.\n\t\tl: [\"[0-9]{3}\", Date.prototype.setMilliseconds, \"milliseconds\", function () {\n\t\t\treturn pad(Date.prototype.getMilliseconds.call(this), 3);\n\t\t}], //Milliseconds. 3 digits.\n\t\tL: [\"[0-9]{2}\", Date.prototype.setMilliseconds, \"milliseconds\", function () {\n\t\t\treturn pad(Date.prototype.getMilliseconds.call(this), 2);\n\t\t}], //Milliseconds. 2 digits.\n\t\tt: [\"[ap]\"], //Lowercase, single-character time marker string: a or p.\n\t\ttt: [\"[ap]m\"], //two-character time marker string: am or pm.\n\t\tT: [\"[AP]\"], //single-character time marker string: A or P.\n\t\tTT: [\"[AP]M\"], //two-character time marker string: AM or PM.\n\t\tZ: [\"\"], //US timezone abbreviation, e.g. EST or MDT. With non-US timezones or in the Opera browser, the GMT/UTC offset is returned, e.g. GMT-0500\n\t\to: [\"\"], //GMT/UTC timezone offset, e.g. -0500 or +0230.\n\t\tS: [\"\"] //The date's ordinal suffix (st, nd, rd, or th).\n\t},\n\tformatAlias = {\n\t\tisoDate: \"yyyy-mm-dd\", //2007-06-09\n\t\tisoTime: \"HH:MM:ss\", //17:46:21\n\t\tisoDateTime: \"yyyy-mm-dd'T'HH:MM:ss\", //2007-06-09T17:46:21\n\t\tisoUtcDateTime: \"UTC:yyyy-mm-dd'T'HH:MM:ss'Z'\" //2007-06-09T22:46:21Z\n\t};\n\nfunction getTokenizer(opts) {\n\tif (!opts.tokenizer) {\n\t\tvar tokens = [];\n\t\tfor (var ndx in formatCode) {\n\t\t\tif (tokens.indexOf(ndx[0]) === -1) {\n\t\t\t\ttokens.push(ndx[0]);\n\t\t\t}\n\t\t}\n\t\topts.tokenizer = \"(\" + tokens.join(\"+|\") + \")+?|.\";\n\t\topts.tokenizer = new RegExp(opts.tokenizer, \"g\");\n\t}\n\n\treturn opts.tokenizer;\n}\n\nfunction isValidDate(dateParts, currentResult) {\n\treturn !isFinite(dateParts.rawday)\n\t|| (dateParts.day == \"29\" && !isFinite(dateParts.rawyear))\n\t|| new Date(dateParts.date.getFullYear(), isFinite(dateParts.rawmonth) ? dateParts.month : dateParts.date.getMonth() + 1, 0).getDate() >= dateParts.day\n\t\t? currentResult\n\t\t: false; //take corrective action if possible\n}\n\nfunction isDateInRange(dateParts, opts) {\n\tvar result = true;\n\tif (opts.min) {\n\t\tif (dateParts[\"rawyear\"]) {\n\t\t\tvar rawYear = dateParts[\"rawyear\"].replace(/[^0-9]/g, \"\"),\n\t\t\t\tminYear = opts.min.year.substr(0, rawYear.length);\n\t\t\tresult = minYear <= rawYear;\n\t\t}\n\t\tif (dateParts[\"year\"] === dateParts[\"rawyear\"]) {\n\t\t\tif (opts.min.date.getTime() === opts.min.date.getTime()) {\n\t\t\t\tresult = opts.min.date.getTime() <= dateParts.date.getTime();\n\t\t\t}\n\t\t}\n\t}\n\n\tif (result && opts.max && opts.max.date.getTime() === opts.max.date.getTime()) {\n\t\tresult = opts.max.date.getTime() >= dateParts.date.getTime();\n\t}\n\treturn result;\n}\n\n//parse the given format and return a mask pattern\n//when a dateObjValue is passed a datestring in the requested format is returned\nfunction parse(format, dateObjValue, opts, raw) {\n\t//parse format to regex string\n\tvar mask = \"\", match;\n\twhile ((match = getTokenizer(opts).exec(format))) {\n\t\tif (dateObjValue === undefined) {\n\t\t\tif (formatCode[match[0]]) {\n\t\t\t\tmask += \"(\" + formatCode[match[0]][0] + \")\";\n\t\t\t} else {\n\t\t\t\tswitch (match[0]) {\n\t\t\t\t\tcase \"[\":\n\t\t\t\t\t\tmask += \"(\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"]\":\n\t\t\t\t\t\tmask += \")?\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tmask += Inputmask.escapeRegex(match[0]);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (formatCode[match[0]]) {\n\t\t\t\tif (raw !== true && formatCode[match[0]][3]) {\n\t\t\t\t\tvar getFn = formatCode[match[0]][3];\n\t\t\t\t\tmask += getFn.call(dateObjValue.date);\n\t\t\t\t} else if (formatCode[match[0]][2]) {\n\t\t\t\t\tmask += dateObjValue[\"raw\" + formatCode[match[0]][2]];\n\t\t\t\t} else {\n\t\t\t\t\tmask += match[0];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmask += match[0];\n\t\t\t}\n\t\t}\n\t}\n\treturn mask;\n}\n\n//padding function\nfunction pad(val, len) {\n\tval = String(val);\n\tlen = len || 2;\n\twhile (val.length < len) val = \"0\" + val;\n\treturn val;\n}\n\nfunction analyseMask(maskString, format, opts) {\n\tvar dateObj = {\"date\": new Date(1, 0, 1)}, targetProp, mask = maskString, match, dateOperation;\n\n\tfunction extendProperty(value) {\n\t\tvar correctedValue = value.replace(/[^0-9]/g, \"0\");\n\t\t// if (correctedValue != value) { //only do correction on incomplete values\n\t\t//     //determine best validation match\n\t\t//     var enteredPart = value.replace(/[^0-9]/g, \"\"),\n\t\t//         enteredPartIndex = value.indexOf(enteredPart),\n\t\t//         minPart = (opts.min && opts.min[targetProp] || value).slice(enteredPartIndex, enteredPartIndex + enteredPart.length),\n\t\t//         maxPart = (opts.max && opts.max[targetProp] || value).slice(enteredPartIndex, enteredPartIndex + enteredPart.length),\n\t\t//         correctedPart = enteredPart < minPart ? minPart : (enteredPart > maxPart ? maxPart : correctedValue.slice(enteredPartIndex, enteredPartIndex + enteredPart.length));\n\t\t//     correctedValue = correctedValue.split(\"\");\n\t\t//     correctedValue.splice(enteredPartIndex, 1, correctedPart);\n\t\t//     correctedValue = correctedValue.join(\"\");\n\t\t// }\n\t\treturn correctedValue;\n\t}\n\n\tfunction setValue(dateObj, value, opts) {\n\t\tdateObj[targetProp] = extendProperty(value);\n\t\tdateObj[\"raw\" + targetProp] = value;\n\n\t\tif (dateOperation !== undefined) {\n\t\t\tdateOperation.call(dateObj.date, targetProp == \"month\" ? parseInt(dateObj[targetProp]) - 1 : dateObj[targetProp]);\n\t\t}\n\t}\n\n\tif (typeof mask === \"string\") {\n\t\twhile ((match = getTokenizer(opts).exec(format))) {\n\t\t\tvar value = mask.slice(0, match[0].length);\n\t\t\tif (formatCode.hasOwnProperty(match[0])) {\n\t\t\t\t// targetValidator = formatCode[match[0]][0];\n\t\t\t\ttargetProp = formatCode[match[0]][2];\n\t\t\t\tdateOperation = formatCode[match[0]][1];\n\t\t\t\tsetValue(dateObj, value, opts);\n\t\t\t}\n\t\t\tmask = mask.slice(value.length);\n\t\t}\n\n\t\treturn dateObj;\n\t} else if (mask && typeof mask === \"object\" && mask.hasOwnProperty(\"date\")) {\n\t\treturn mask;\n\t}\n\treturn undefined;\n}\n\nInputmask.extendAliases({\n\t\"datetime\": {\n\t\tmask: function (opts) {\n\t\t\t//localize\n\t\t\tformatCode.S = opts.i18n.ordinalSuffix.join(\"|\");\n\n\t\t\topts.inputFormat = formatAlias[opts.inputFormat] || opts.inputFormat; //resolve possible formatAlias\n\t\t\topts.displayFormat = formatAlias[opts.displayFormat] || opts.displayFormat || opts.inputFormat; //resolve possible formatAlias\n\t\t\topts.outputFormat = formatAlias[opts.outputFormat] || opts.outputFormat || opts.inputFormat; //resolve possible formatAlias\n\t\t\topts.placeholder = opts.placeholder !== \"\" ? opts.placeholder : opts.inputFormat.replace(/[[\\]]/, \"\");\n\t\t\topts.regex = parse(opts.inputFormat, undefined, opts);\n\t\t\t// console.log(opts.regex);\n\t\t\treturn null; //migrate to regex mask\n\t\t},\n\t\tplaceholder: \"\", //set default as none (~ auto); when a custom placeholder is passed it will be used\n\t\tinputFormat: \"isoDateTime\", //format used to input the date\n\t\tdisplayFormat: undefined, //visual format when the input looses focus\n\t\toutputFormat: undefined, //unmasking format\n\t\tmin: null, //needs to be in the same format as the inputfornat\n\t\tmax: null, //needs to be in the same format as the inputfornat,\n\t\t// Internationalization strings\n\t\ti18n: {\n\t\t\tdayNames: [\n\t\t\t\t\"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", \"Sun\",\n\t\t\t\t\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"\n\t\t\t],\n\t\t\tmonthNames: [\n\t\t\t\t\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\",\n\t\t\t\t\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"\n\t\t\t],\n\t\t\tordinalSuffix: [\"st\", \"nd\", \"rd\", \"th\"]\n\t\t},\n\t\tpreValidation: function (buffer, pos, c, isSelection, opts, maskset) {\n\t\t\tvar calcPos = 0, targetMatch, match;\n\t\t\tif (isNaN(c) && buffer[pos] !== c) {\n\t\t\t\twhile ((match = getTokenizer(opts).exec(opts.inputFormat))) {\n\t\t\t\t\tcalcPos += match[0].length;\n\t\t\t\t\tif (calcPos >= pos) {\n\t\t\t\t\t\ttargetMatch = match;\n\t\t\t\t\t\tmatch = getTokenizer(opts).exec(opts.inputFormat);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (match && match[0] === c && targetMatch[0].length > 1) {\n\t\t\t\t\tbuffer[pos] = buffer[pos - 1];\n\t\t\t\t\tbuffer[pos - 1] = \"0\";\n\t\t\t\t\treturn {\n\t\t\t\t\t\tfuzzy: true,\n\t\t\t\t\t\tbuffer: buffer,\n\t\t\t\t\t\trefreshFromBuffer: {start: pos - 1, end: pos + 1},\n\t\t\t\t\t\tpos: pos + 1\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\t\tpostValidation: function (buffer, pos, currentResult, opts) {\n\t\t\topts.min = analyseMask(opts.min, opts.inputFormat, opts);\n\t\t\topts.max = analyseMask(opts.max, opts.inputFormat, opts);\n\n\t\t\tif (currentResult.fuzzy) {\n\t\t\t\tbuffer = currentResult.buffer;\n\t\t\t\tpos = currentResult.pos;\n\t\t\t}\n\n\t\t\tvar result = currentResult, dateParts = analyseMask(buffer.join(\"\"), opts.inputFormat, opts);\n\t\t\tif (result && dateParts.date.getTime() === dateParts.date.getTime()) { //check for a valid date ~ an invalid date returns NaN which isn't equal\n\t\t\t\tresult = isValidDate(dateParts, result);\n\t\t\t\tresult = result && isDateInRange(dateParts, opts);\n\t\t\t}\n\n\t\t\tif (pos && result && currentResult.pos !== pos) {\n\t\t\t\treturn {\n\t\t\t\t\tbuffer: parse(opts.inputFormat, dateParts, opts),\n\t\t\t\t\trefreshFromBuffer: {start: pos, end: currentResult.pos}\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn result;\n\t\t},\n\t\tonKeyDown: function (e, buffer, caretPos, opts) {\n\t\t\tvar input = this;\n\t\t\tif (e.ctrlKey && e.keyCode === Inputmask.keyCode.RIGHT) {\n\t\t\t\tvar today = new Date(), match, date = \"\";\n\n\t\t\t\twhile ((match = getTokenizer(opts).exec(opts.inputFormat))) {\n\t\t\t\t\tif (match[0].charAt(0) === \"d\") {\n\t\t\t\t\t\tdate += pad(today.getDate(), match[0].length);\n\t\t\t\t\t} else if (match[0].charAt(0) === \"m\") {\n\t\t\t\t\t\tdate += pad((today.getMonth() + 1), match[0].length);\n\t\t\t\t\t} else if (match[0] === \"yyyy\") {\n\t\t\t\t\t\tdate += today.getFullYear().toString();\n\t\t\t\t\t} else if (match[0].charAt(0) === \"y\") {\n\t\t\t\t\t\tdate += pad(today.getYear(), match[0].length);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tinput.inputmask._valueSet(date);\n\t\t\t\t$(input).trigger(\"setvalue\");\n\t\t\t}\n\t\t},\n\t\tonUnMask: function (maskedValue, unmaskedValue, opts) {\n\t\t\treturn unmaskedValue ? parse(opts.outputFormat, analyseMask(maskedValue, opts.inputFormat, opts), opts, true) : unmaskedValue;\n\t\t},\n\t\tcasing: function (elem, test, pos, validPositions) {\n\t\t\tif (test.nativeDef.indexOf(\"[ap]\") == 0) return elem.toLowerCase();\n\t\t\tif (test.nativeDef.indexOf(\"[AP]\") == 0) return elem.toUpperCase();\n\t\t\treturn elem;\n\t\t},\n\t\tinsertMode: false,\n\t\tshiftPositions: false\n\t}\n});\n\nmodule.exports = Inputmask;\n","/*\n Input Mask plugin extensions\n http://github.com/RobinHerbots/jquery.inputmask\n Copyright (c) Robin Herbots\n Licensed under the MIT license\n */\nvar Inputmask = require(\"../inputmask\"), $ = Inputmask.dependencyLib;\n\nfunction autoEscape(txt, opts) {\n\tvar escapedTxt = \"\";\n\tfor (var i = 0; i < txt.length; i++) {\n\t\tif (Inputmask.prototype.definitions[txt.charAt(i)] ||\n\t\t\topts.definitions[txt.charAt(i)] ||\n\t\t\topts.optionalmarker.start === txt.charAt(i) ||\n\t\t\topts.optionalmarker.end === txt.charAt(i) ||\n\t\t\topts.quantifiermarker.start === txt.charAt(i) ||\n\t\t\topts.quantifiermarker.end === txt.charAt(i) ||\n\t\t\topts.groupmarker.start === txt.charAt(i) ||\n\t\t\topts.groupmarker.end === txt.charAt(i) ||\n\t\t\topts.alternatormarker === txt.charAt(i)) {\n\t\t\tescapedTxt += \"\\\\\" + txt.charAt(i);\n\t\t} else {\n\t\t\tescapedTxt += txt.charAt(i);\n\t\t}\n\t}\n\treturn escapedTxt;\n}\n\nfunction alignDigits(buffer, digits, opts) {\n\tif (digits > 0 && !opts.digitsOptional && buffer.length > 0) {\n\t\tvar radixPosition = $.inArray(opts.radixPoint, buffer);\n\t\tif (radixPosition === -1) {\n\t\t\tbuffer.push(opts.radixPoint);\n\t\t\tradixPosition = buffer.length - 1;\n\t\t}\n\t\tfor (var i = 1; i <= digits; i++) {\n\t\t\tbuffer[radixPosition + i] = buffer[radixPosition + i] || \"0\";\n\t\t}\n\t}\n\treturn buffer;\n}\n\nfunction FindPlusValidator(maskset) {\n\tvar posNdx = 0;\n\tfor (posNdx in maskset.validPositions) ;\n\tfor (var tstNdx in maskset.tests) {\n\t\tif (tstNdx >= posNdx) {\n\t\t\tfor (var ndx = 0, ndxl = maskset.tests[tstNdx].length; ndx < ndxl; ndx++) {\n\t\t\t\tif (maskset.tests[tstNdx][ndx].match.def === \"+\") {\n\t\t\t\t\treturn parseInt(tstNdx) + (maskset.validPositions[tstNdx] !== undefined ? 1 : 0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn parseInt(posNdx);\n}\n\nfunction parseMinMaxOptions(opts) {\n\tif (opts.parseMinMaxOptions === undefined) {\n\t\t// convert min and max options\n\t\tif (opts.min !== null) {\n\t\t\topts.min = opts.min.toString().replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), \"g\"), \"\");\n\t\t\tif (opts.radixPoint === \",\") opts.min = opts.min.replace(opts.radixPoint, \".\");\n\t\t\topts.min = isFinite(opts.min) ? parseFloat(opts.min) : NaN;\n\t\t\tif (isNaN(opts.min)) opts.min = Number.MIN_VALUE;\n\t\t}\n\t\tif (opts.max !== null) {\n\t\t\topts.max = opts.max.toString().replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), \"g\"), \"\");\n\t\t\tif (opts.radixPoint === \",\") opts.max = opts.max.replace(opts.radixPoint, \".\");\n\t\t\topts.max = isFinite(opts.max) ? parseFloat(opts.max) : NaN;\n\t\t\tif (isNaN(opts.max)) opts.max = Number.MAX_VALUE;\n\t\t}\n\t\topts.parseMinMaxOptions = \"done\";\n\t}\n}\n\nfunction genMask(opts) {\n\topts.repeat = 0;\n\t//treat equal separator and radixpoint\n\tif (opts.groupSeparator === opts.radixPoint && opts.digits && opts.digits !== \"0\") {\n\t\tif (opts.radixPoint === \".\") {\n\t\t\topts.groupSeparator = \",\";\n\t\t} else if (opts.radixPoint === \",\") {\n\t\t\topts.groupSeparator = \".\";\n\t\t} else {\n\t\t\topts.groupSeparator = \"\";\n\t\t}\n\t}\n\t//prevent conflict with default skipOptionalPartCharacter\n\tif (opts.groupSeparator === \" \") {\n\t\topts.skipOptionalPartCharacter = undefined;\n\t}\n\n\t//enforce placeholder to single\n\tif (opts.placeholder.length > 1) {\n\t\topts.placeholder = opts.placeholder.charAt(0);\n\t}\n\t//only allow radixfocus when placeholder = 0\n\tif (opts.positionCaretOnClick === \"radixFocus\" && opts.placeholder === \"\") {\n\t\topts.positionCaretOnClick = \"lvp\";\n\t}\n\n\tvar decimalDef = \"0\";\n\tif (opts.numericInput === true && opts.__financeInput === undefined) { //finance people input style\n\t\tdecimalDef = \"1\";\n\t\topts.positionCaretOnClick = opts.positionCaretOnClick === \"radixFocus\" ? \"lvp\" : opts.positionCaretOnClick;\n\t\topts.digitsOptional = false;\n\t\tif (isNaN(opts.digits)) opts.digits = 2;\n\t\topts._radixDance = false;\n\t} else {\n\t\topts.__financeInput = false; //needed to keep original selection when remasking\n\t\topts.numericInput = true;\n\t}\n\n\tvar mask = \"[+]\", altMask;\n\tmask += autoEscape(opts.prefix, opts);\n\tif (opts.groupSeparator !== \"\") {\n\t\tmask += opts._mask(opts);\n\t} else {\n\t\tmask += \"9{+}\";\n\t}\n\tif (opts.digits !== undefined) {\n\t\tvar dq = opts.digits.toString().split(\",\");\n\t\tif (isFinite(dq[0]) && dq[1] && isFinite(dq[1])) {\n\t\t\tmask += opts.radixPoint + decimalDef + \"{\" + opts.digits + \"}\";\n\t\t} else if (isNaN(opts.digits) || parseInt(opts.digits) > 0) {\n\t\t\tif (opts.digitsOptional) {\n\t\t\t\taltMask = mask + opts.radixPoint + decimalDef + \"{0,\" + opts.digits + \"}\";\n\t\t\t\t// mask += \"[\" + opts.radixPoint + \"]\";\n\t\t\t\topts.keepStatic = true;\n\t\t\t} else {\n\t\t\t\tmask += opts.radixPoint + decimalDef + \"{\" + opts.digits + \"}\";\n\t\t\t}\n\t\t}\n\t}\n\tmask += autoEscape(opts.suffix, opts);\n\tmask += \"[-]\";\n\n\tif (altMask) {\n\t\tmask = [(altMask + autoEscape(opts.suffix, opts) + \"[-]\"), mask];\n\t}\n\n\n\topts.greedy = false; //enforce greedy false\n\n\tparseMinMaxOptions(opts);\n\tconsole.log(mask);\n\treturn mask;\n}\n\nfunction hanndleRadixDance(pos, c, radixPos, opts) {\n\tif (opts._radixDance && opts.numericInput) {\n\t\tif (pos <= radixPos && (radixPos > 0 || c == opts.radixPoint)) {\n\t\t\tpos -= 1;\n\t\t}\n\t}\n\treturn pos;\n}\n\nfunction decimalValidator(chrs, maskset, pos, strict, opts) {\n\tvar radixPos = maskset.buffer.indexOf(opts.radixPoint),\n\t\tresult = radixPos !== -1 && new RegExp(\"[0-9\\uFF11-\\uFF19]\").test(chrs);\n\tif (opts._radixDance && result && maskset.validPositions[radixPos] == undefined) {\n\t\treturn {\n\t\t\tinsert: {\n\t\t\t\tpos: radixPos === pos ? radixPos + 1 : radixPos,\n\t\t\t\tc: opts.radixPoint\n\t\t\t},\n\t\t\tpos: pos\n\t\t};\n\t}\n\n\treturn result;\n}\n\n//number aliases\nInputmask.extendAliases({\n\t\"numeric\": {\n\t\tmask: genMask,\n\t\t_mask: function (opts) {\n\t\t\treturn \"(\" + opts.groupSeparator + \"999){+|1}\";\n\t\t},\n\t\tplaceholder: \"0\",\n\t\tgreedy: false,\n\t\tdigits: \"*\", //number of fractionalDigits\n\t\tdigitsOptional: true,\n\t\tenforceDigitsOnBlur: false,\n\t\tradixPoint: \".\",\n\t\tpositionCaretOnClick: \"radixFocus\",\n\t\t_radixDance: true,\n\t\tgroupSeparator: \"\",\n\t\tallowMinus: true,\n\t\tnegationSymbol: {\n\t\t\tfront: \"-\", //\"(\"\n\t\t\tback: \"\" //\")\"\n\t\t},\n\t\tprefix: \"\",\n\t\tsuffix: \"\",\n\t\trightAlign: true,\n\t\tmin: null, //minimum value\n\t\tmax: null, //maximum value\n\t\tstep: 1,\n\t\tinsertMode: true,\n\t\tautoUnmask: false,\n\t\tunmaskAsNumber: false,\n\t\tinputmode: \"numeric\",\n\t\tdefinitions: {\n\t\t\t\"0\": {\n\t\t\t\tvalidator: decimalValidator\n\t\t\t},\n\t\t\t\"1\": {\n\t\t\t\tvalidator: decimalValidator,\n\t\t\t\tdefinitionSymbol: \"*\"\n\t\t\t},\n\t\t\t\"+\": {\n\t\t\t\tvalidator: function (chrs, maskset, pos, strict, opts) {\n\t\t\t\t\treturn (opts.allowMinus && (chrs === \"-\" || chrs === opts.negationSymbol.front));\n\n\t\t\t\t}\n\t\t\t},\n\t\t\t\"-\": {\n\t\t\t\tvalidator: function (chrs, maskset, pos, strict, opts) {\n\t\t\t\t\treturn (opts.allowMinus && chrs === opts.negationSymbol.back);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tpreValidation: function (buffer, pos, c, isSelection, opts, maskset) {\n\t\t\tvar radixPos = $.inArray(opts.radixPoint, buffer);\n\t\t\tpos = hanndleRadixDance(pos, c, radixPos, opts);\n\t\t\tif (c === \"-\" || c === opts.negationSymbol.front) {\n\t\t\t\tif (opts.allowMinus !== true) return false;\n\t\t\t\tvar isNegative = false;\n\t\t\t\t$.each(maskset.validPositions, function (ndx, tst) {\n\t\t\t\t\tif (tst.match.def === \"+\") {\n\t\t\t\t\t\tisNegative = ndx;\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn isNegative !== false ? {\n\t\t\t\t\tremove: parseInt(isNegative),\n\t\t\t\t\tcaret: radixPos > pos ? pos + 1 : pos\n\t\t\t\t} : {\n\t\t\t\t\tinsert: {pos: FindPlusValidator(maskset), c: c, fromIsValid: true},\n\t\t\t\t\tcaret: radixPos > pos ? pos + 1 : pos\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (radixPos !== -1 && (opts._radixDance === true && isSelection === false && c === opts.radixPoint && (opts.digits !== undefined && (isNaN(opts.digits) || parseInt(opts.digits) > 0)) && radixPos !== pos)) {\n\t\t\t\treturn {\n\t\t\t\t\t\"caret\": opts._radixDance && pos === radixPos - 1 ? radixPos + 1 : radixPos\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn {rewritePosition: pos};\n\t\t},\n\t\tpostValidation: function (buffer, pos, currentResult, opts) {\n\t\t\tif (opts.min !== null || opts.max !== null) {\n\t\t\t\tvar unmasked = opts.onUnMask(buffer.slice().reverse().join(\"\"), undefined, $.extend({}, opts, {\n\t\t\t\t\tunmaskAsNumber: true\n\t\t\t\t}));\n\t\t\t\tif (opts.min !== null && unmasked < opts.min && unmasked.toString().length >= opts.min.toString().length) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (opts.max !== null && unmasked > opts.max) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn currentResult;\n\t\t},\n\t\tonUnMask: function (maskedValue, unmaskedValue, opts) {\n\t\t\tif (unmaskedValue === \"\" && opts.nullable === true) {\n\t\t\t\treturn unmaskedValue;\n\t\t\t}\n\t\t\tvar processValue = maskedValue.replace(opts.prefix, \"\");\n\t\t\tprocessValue = processValue.replace(opts.suffix, \"\");\n\t\t\tprocessValue = processValue.replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), \"g\"), \"\");\n\t\t\tif (opts.placeholder.charAt(0) !== \"\") {\n\t\t\t\tprocessValue = processValue.replace(new RegExp(opts.placeholder.charAt(0), \"g\"), \"0\");\n\t\t\t}\n\t\t\tif (opts.unmaskAsNumber) {\n\t\t\t\tif (opts.radixPoint !== \"\" && processValue.indexOf(opts.radixPoint) !== -1) processValue = processValue.replace(Inputmask.escapeRegex.call(this, opts.radixPoint), \".\");\n\t\t\t\tprocessValue = processValue.replace(new RegExp(\"^\" + Inputmask.escapeRegex(opts.negationSymbol.front)), \"-\");\n\t\t\t\tprocessValue = processValue.replace(new RegExp(Inputmask.escapeRegex(opts.negationSymbol.back) + \"$\"), \"\");\n\t\t\t\treturn Number(processValue);\n\t\t\t}\n\t\t\treturn processValue;\n\t\t},\n\t\tisComplete: function (buffer, opts) {\n\t\t\tvar maskedValue = (opts.numericInput ? buffer.slice().reverse() : buffer).join(\"\");\n\t\t\tmaskedValue = maskedValue.replace(new RegExp(\"^\" + Inputmask.escapeRegex(opts.negationSymbol.front)), \"-\");\n\t\t\tmaskedValue = maskedValue.replace(new RegExp(Inputmask.escapeRegex(opts.negationSymbol.back) + \"$\"), \"\");\n\t\t\tmaskedValue = maskedValue.replace(opts.prefix, \"\");\n\t\t\tmaskedValue = maskedValue.replace(opts.suffix, \"\");\n\t\t\tmaskedValue = maskedValue.replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator) + \"([0-9]{3})\", \"g\"), \"$1\");\n\t\t\tif (opts.radixPoint === \",\") maskedValue = maskedValue.replace(Inputmask.escapeRegex(opts.radixPoint), \".\");\n\t\t\treturn isFinite(maskedValue);\n\t\t},\n\t\tonBeforeMask: function (initialValue, opts) {\n\t\t\tvar radixPoint = opts.radixPoint || \",\";\n\n\t\t\tif ((typeof initialValue == \"number\" || opts.inputType === \"number\") && radixPoint !== \"\") {\n\t\t\t\tinitialValue = initialValue.toString().replace(\".\", radixPoint);\n\t\t\t}\n\n\t\t\tvar valueParts = initialValue.split(radixPoint),\n\t\t\t\tintegerPart = valueParts[0].replace(/[^\\-0-9]/g, \"\"),\n\t\t\t\tdecimalPart = valueParts.length > 1 ? valueParts[1].replace(/[^0-9]/g, \"\") : \"\";\n\n\t\t\tinitialValue = integerPart + (decimalPart !== \"\" ? radixPoint + decimalPart : decimalPart);\n\n\t\t\tvar digits = 0;\n\t\t\tif (radixPoint !== \"\") {\n\t\t\t\tdigits = decimalPart.length;\n\t\t\t\tif (decimalPart !== \"\") {\n\t\t\t\t\tvar digitsFactor = Math.pow(10, digits || 1);\n\t\t\t\t\tif (isFinite(opts.digits)) {\n\t\t\t\t\t\tdigits = parseInt(opts.digits);\n\t\t\t\t\t\tdigitsFactor = Math.pow(10, digits);\n\t\t\t\t\t}\n\n\t\t\t\t\t//make the initialValue a valid javascript number for the parsefloat\n\t\t\t\t\tinitialValue = initialValue.replace(Inputmask.escapeRegex(radixPoint), \".\");\n\t\t\t\t\tif (isFinite(initialValue)) {\n\t\t\t\t\t\tinitialValue = Math.round(parseFloat(initialValue) * digitsFactor) / digitsFactor;\n\t\t\t\t\t}\n\t\t\t\t\tinitialValue = initialValue.toString().replace(\".\", radixPoint);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//this needs to be in a separate part and not directly in decimalPart to allow rounding\n\t\t\tif (opts.digits === 0 && initialValue.indexOf(Inputmask.escapeRegex(radixPoint)) !== -1) {\n\t\t\t\tinitialValue = initialValue.substring(0, initialValue.indexOf(Inputmask.escapeRegex(radixPoint)));\n\t\t\t}\n\t\t\treturn alignDigits(initialValue.toString().split(\"\"), digits, opts).join(\"\");\n\t\t},\n\t\t// onBeforeWrite: function (e, buffer, caretPos, opts) {\n\t\t// \tvar result;\n\t\t// \tif (e) {\n\t\t// \t\tswitch (e.type) {\n\t\t// \t\t\tcase \"blur\":\n\t\t// \t\t\tcase \"checkval\":\n\t\t// \t\t\t\tif (opts.min !== null || opts.max !== null) {\n\t\t// \t\t\t\t\tvar unmasked = opts.onUnMask(buffer.join(\"\"), undefined, $.extend({}, opts, {\n\t\t// \t\t\t\t\t\tunmaskAsNumber: true\n\t\t// \t\t\t\t\t}));\n\t\t// \t\t\t\t\tif (opts.min !== null && unmasked < opts.min) {\n\t\t// \t\t\t\t\t\tresult = {refreshFromBuffer: true, buffer: opts.min.toString().split(\"\")};\n\t\t// \t\t\t\t\t} else if (opts.max !== null && unmasked > opts.max) {\n\t\t// \t\t\t\t\t\tresult = {refreshFromBuffer: true, buffer: opts.max.toString().split(\"\")};\n\t\t// \t\t\t\t\t}\n\t\t// \t\t\t\t}\n\t\t// \t\t}\n\t\t// \t}\n\t\t// \treturn result;\n\t\t// },\n\t\tonKeyDown: function (e, buffer, caretPos, opts) {\n\t\t\tvar $input = $(this);\n\t\t\tif (e.ctrlKey) {\n\t\t\t\tswitch (e.keyCode) {\n\t\t\t\t\tcase Inputmask.keyCode.UP:\n\t\t\t\t\t\t$input.val(parseFloat(this.inputmask.unmaskedvalue()) + parseInt(opts.step));\n\t\t\t\t\t\t$input.trigger(\"setvalue\");\n\t\t\t\t\t\treturn false;\n\t\t\t\t\tcase Inputmask.keyCode.DOWN:\n\t\t\t\t\t\t$input.val(parseFloat(this.inputmask.unmaskedvalue()) - parseInt(opts.step));\n\t\t\t\t\t\t$input.trigger(\"setvalue\");\n\t\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\t\"currency\": {\n\t\tprefix: \"$ \",\n\t\tgroupSeparator: \",\",\n\t\talias: \"numeric\",\n\t\tplaceholder: \"0\",\n\t\tdigits: 2,\n\t\tdigitsOptional: false\n\t},\n\t\"decimal\": {\n\t\talias: \"numeric\"\n\t},\n\t\"integer\": {\n\t\talias: \"numeric\",\n\t\tdigits: 0\n\t},\n\t\"percentage\": {\n\t\talias: \"integer\",\n\t\tmin: 0,\n\t\tmax: 100,\n\t\tsuffix: \" %\",\n\t\tallowMinus: false\n\t},\n\t\"indianns\": { //indian numbering system\n\t\talias: \"numeric\",\n\t\t_mask: function (opts) {\n\t\t\treturn \"(\" + opts.groupSeparator + \"99){*|1}(\" + opts.groupSeparator + \"999){1|1}\";\n\t\t},\n\t\tgroupSeparator: \",\",\n\t\tradixPoint: \".\",\n\t\tplaceholder: \"0\",\n\t\tdigits: 2,\n\t\tdigitsOptional: false\n\t}\n});\nmodule.exports = Inputmask;\n"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n"],"sourceRoot":""}